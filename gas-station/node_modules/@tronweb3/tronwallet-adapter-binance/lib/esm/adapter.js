var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Adapter, AdapterState, isInBrowser, WalletReadyState, WalletSignMessageError, WalletNotFoundError, WalletDisconnectedError, WalletConnectionError, WalletSignTransactionError, WalletGetNetworkError, NetworkType, } from '@tronweb3/tronwallet-abstract-adapter';
export const BinanceWalletAdapterName = 'Binance Wallet';
const chainIdNetworkMap = {
    '0x2b6653dc': NetworkType.Mainnet,
    '0x94a9059e': NetworkType.Shasta,
    '0xcd8690dc': NetworkType.Nile,
};
export class BinanceWalletAdapter extends Adapter {
    constructor(config = {}) {
        super();
        this.name = BinanceWalletAdapterName;
        this.url = 'https://www.binance.com/en/binancewallet';
        this.icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMEIwRTExIi8+CjxwYXRoIGQ9Ik01IDE1TDcuMjU4MDYgMTIuNzQxOUw5LjUxNjEzIDE1TDcuMjU4MDYgMTcuMjU4MUw1IDE1WiIgZmlsbD0iI0YwQjkwQiIvPgo8cGF0aCBkPSJNOC44NzA5NyAxMS4xMjlMMTUgNUwyMS4xMjkgMTEuMTI5TDE4Ljg3MSAxMy4zODcxTDE1IDkuNTE2MTNMMTEuMTI5IDEzLjM4NzFMOC44NzA5NyAxMS4xMjlaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0xMi43NDE5IDE1TDE1IDEyLjc0MTlMMTcuMjU4MSAxNUwxNSAxNy4yNTgxTDEyLjc0MTkgMTVaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0xMS4xMjkgMTYuNjEyOUw4Ljg3MDk3IDE4Ljg3MUwxNSAyNUwyMS4xMjkgMTguODcxTDE4Ljg3MSAxNi42MTI5TDE1IDIwLjQ4MzlMMTEuMTI5IDE2LjYxMjlaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0yMC40ODM5IDE1TDIyLjc0MTkgMTIuNzQxOUwyNSAxNUwyMi43NDE5IDE3LjI1ODFMMjAuNDgzOSAxNVoiIGZpbGw9IiNGMEI5MEIiLz4KPC9zdmc+Cg==';
        this._readyState = isInBrowser() ? WalletReadyState.Loading : WalletReadyState.NotFound;
        this._state = AdapterState.Loading;
        this._onAccountsChanged = (address) => {
            const preAddr = this.address || '';
            this.setAddress(address[0]);
            this.emit('accountsChanged', this.address || '', preAddr);
        };
        this._checkPromise = null;
        this._updateProvider = () => {
            var _a;
            let state = this.state;
            let address = this.address;
            if ((_a = window.binancew3w) === null || _a === void 0 ? void 0 : _a.tron) {
                this._provider = window.binancew3w.tron;
                address = null; // Will be set when connected
                state = AdapterState.Disconnect;
            }
            else {
                this._provider = null;
                address = null;
                state = AdapterState.NotFound;
            }
            this.setAddress(address);
            this.setState(state);
        };
        const { checkTimeout = 2 * 1000, openUrlWhenWalletNotFound = true } = config;
        if (typeof checkTimeout !== 'number') {
            throw new Error('[BinanceWalletAdapter] config.checkTimeout should be a number');
        }
        this.config = {
            checkTimeout,
            openUrlWhenWalletNotFound,
        };
        this._connecting = false;
        this._provider = null;
        this._address = null;
        if (!isInBrowser()) {
            this._readyState = WalletReadyState.NotFound;
            this.setState(AdapterState.NotFound);
            return;
        }
        this._checkWallet().then(() => {
            if (this.connected) {
                this.emit('connect', this.address || '');
                this._listenEvent();
            }
        });
    }
    get address() {
        return this._address;
    }
    get state() {
        return this._state;
    }
    get readyState() {
        return this._readyState;
    }
    get connecting() {
        return this._connecting;
    }
    /**
     * Get network information used by Binance Wallet.
     * @returns {Network} Current network information.
     */
    network() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._checkWallet();
                if (this.state !== AdapterState.Connected)
                    throw new WalletDisconnectedError();
                try {
                    const chainId = this._provider.getChainId();
                    return {
                        networkType: chainIdNetworkMap[chainId] || NetworkType.Unknown,
                        chainId,
                        fullNode: '',
                        solidityNode: '',
                        eventServer: '',
                    };
                }
                catch (e) {
                    throw new WalletGetNetworkError(e === null || e === void 0 ? void 0 : e.message, e);
                }
            }
            catch (e) {
                this.emit('error', e);
                throw e;
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.connected || this.connecting)
                    return;
                yield this._checkWallet();
                if (this.state === AdapterState.NotFound) {
                    if (this.config.openUrlWhenWalletNotFound !== false && isInBrowser()) {
                        window.open(this.url, '_blank');
                    }
                    throw new WalletNotFoundError();
                }
                this._connecting = true;
                try {
                    const { address } = yield this._provider.getAccount();
                    this.setAddress(address);
                    this.setState(AdapterState.Connected);
                    this.emit('connect', address);
                    this._listenEvent();
                }
                catch (error) {
                    throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
            finally {
                this._connecting = false;
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== AdapterState.Connected) {
                return;
            }
            yield this._provider.disconnect();
            this.setAddress(null);
            this.setState(AdapterState.Disconnect);
            this.emit('disconnect');
            this._stopListenEvent();
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.state !== AdapterState.Connected)
                    throw new WalletDisconnectedError();
                try {
                    return yield this._provider.signMessageV2(message);
                }
                catch (error) {
                    throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.state !== AdapterState.Connected)
                    throw new WalletDisconnectedError();
                try {
                    return yield this._provider.signTransaction(transaction);
                }
                catch (error) {
                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
        });
    }
    _listenEvent() {
        this._stopListenEvent();
        this._provider.on('accountsChanged', this._onAccountsChanged);
    }
    _stopListenEvent() {
        this._provider.removeListener('accountsChanged', this._onAccountsChanged);
    }
    _checkWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readyState === WalletReadyState.Found) {
                return true;
            }
            if (this._checkPromise) {
                return this._checkPromise;
            }
            const interval = 100;
            const maxTimes = Math.floor(this.config.checkTimeout / interval);
            let times = 0;
            let timer;
            this._checkPromise = new Promise((resolve) => {
                const check = () => {
                    var _a;
                    times++;
                    const isSupport = !!((_a = window.binancew3w) === null || _a === void 0 ? void 0 : _a.tron);
                    if (isSupport || times > maxTimes) {
                        timer && clearInterval(timer);
                        this._readyState = isSupport ? WalletReadyState.Found : WalletReadyState.NotFound;
                        this._updateProvider();
                        this.emit('readyStateChanged', this.readyState);
                        resolve(isSupport);
                    }
                };
                timer = setInterval(check, interval);
                check();
            });
            return this._checkPromise;
        });
    }
    setAddress(address) {
        this._address = address;
    }
    setState(state) {
        const preState = this.state;
        if (state !== preState) {
            this._state = state;
            this.emit('stateChanged', state);
        }
    }
}
//# sourceMappingURL=adapter.js.map