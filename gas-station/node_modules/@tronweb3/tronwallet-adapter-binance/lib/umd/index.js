(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@binance/w3w-utils')) :
	typeof define === 'function' && define.amd ? define(['@binance/w3w-utils'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global["@tronweb3/tronwallet-adapter-binance"] = factory(global.require$$0));
})(this, (function (require$$0) { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var cjs$1 = {};

	var adapter$1 = {};

	var cjs = {};

	var adapter = {};

	var eventemitter3 = {exports: {}};

	var hasRequiredEventemitter3;

	function requireEventemitter3 () {
		if (hasRequiredEventemitter3) return eventemitter3.exports;
		hasRequiredEventemitter3 = 1;
		(function (module) {

			var has = Object.prototype.hasOwnProperty
			  , prefix = '~';

			/**
			 * Constructor to create a storage for our `EE` objects.
			 * An `Events` instance is a plain object whose properties are event names.
			 *
			 * @constructor
			 * @private
			 */
			function Events() {}

			//
			// We try to not inherit from `Object.prototype`. In some engines creating an
			// instance in this way is faster than calling `Object.create(null)` directly.
			// If `Object.create(null)` is not supported we prefix the event names with a
			// character to make sure that the built-in object properties are not
			// overridden or used as an attack vector.
			//
			if (Object.create) {
			  Events.prototype = Object.create(null);

			  //
			  // This hack is needed because the `__proto__` property is still inherited in
			  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
			  //
			  if (!new Events().__proto__) prefix = false;
			}

			/**
			 * Representation of a single event listener.
			 *
			 * @param {Function} fn The listener function.
			 * @param {*} context The context to invoke the listener with.
			 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
			 * @constructor
			 * @private
			 */
			function EE(fn, context, once) {
			  this.fn = fn;
			  this.context = context;
			  this.once = once || false;
			}

			/**
			 * Add a listener for a given event.
			 *
			 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
			 * @param {(String|Symbol)} event The event name.
			 * @param {Function} fn The listener function.
			 * @param {*} context The context to invoke the listener with.
			 * @param {Boolean} once Specify if the listener is a one-time listener.
			 * @returns {EventEmitter}
			 * @private
			 */
			function addListener(emitter, event, fn, context, once) {
			  if (typeof fn !== 'function') {
			    throw new TypeError('The listener must be a function');
			  }

			  var listener = new EE(fn, context || emitter, once)
			    , evt = prefix ? prefix + event : event;

			  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
			  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
			  else emitter._events[evt] = [emitter._events[evt], listener];

			  return emitter;
			}

			/**
			 * Clear event by name.
			 *
			 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
			 * @param {(String|Symbol)} evt The Event name.
			 * @private
			 */
			function clearEvent(emitter, evt) {
			  if (--emitter._eventsCount === 0) emitter._events = new Events();
			  else delete emitter._events[evt];
			}

			/**
			 * Minimal `EventEmitter` interface that is molded against the Node.js
			 * `EventEmitter` interface.
			 *
			 * @constructor
			 * @public
			 */
			function EventEmitter() {
			  this._events = new Events();
			  this._eventsCount = 0;
			}

			/**
			 * Return an array listing the events for which the emitter has registered
			 * listeners.
			 *
			 * @returns {Array}
			 * @public
			 */
			EventEmitter.prototype.eventNames = function eventNames() {
			  var names = []
			    , events
			    , name;

			  if (this._eventsCount === 0) return names;

			  for (name in (events = this._events)) {
			    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
			  }

			  if (Object.getOwnPropertySymbols) {
			    return names.concat(Object.getOwnPropertySymbols(events));
			  }

			  return names;
			};

			/**
			 * Return the listeners registered for a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @returns {Array} The registered listeners.
			 * @public
			 */
			EventEmitter.prototype.listeners = function listeners(event) {
			  var evt = prefix ? prefix + event : event
			    , handlers = this._events[evt];

			  if (!handlers) return [];
			  if (handlers.fn) return [handlers.fn];

			  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
			    ee[i] = handlers[i].fn;
			  }

			  return ee;
			};

			/**
			 * Return the number of listeners listening to a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @returns {Number} The number of listeners.
			 * @public
			 */
			EventEmitter.prototype.listenerCount = function listenerCount(event) {
			  var evt = prefix ? prefix + event : event
			    , listeners = this._events[evt];

			  if (!listeners) return 0;
			  if (listeners.fn) return 1;
			  return listeners.length;
			};

			/**
			 * Calls each of the listeners registered for a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @returns {Boolean} `true` if the event had listeners, else `false`.
			 * @public
			 */
			EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
			  var evt = prefix ? prefix + event : event;

			  if (!this._events[evt]) return false;

			  var listeners = this._events[evt]
			    , len = arguments.length
			    , args
			    , i;

			  if (listeners.fn) {
			    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

			    switch (len) {
			      case 1: return listeners.fn.call(listeners.context), true;
			      case 2: return listeners.fn.call(listeners.context, a1), true;
			      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
			      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
			      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
			      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
			    }

			    for (i = 1, args = new Array(len -1); i < len; i++) {
			      args[i - 1] = arguments[i];
			    }

			    listeners.fn.apply(listeners.context, args);
			  } else {
			    var length = listeners.length
			      , j;

			    for (i = 0; i < length; i++) {
			      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

			      switch (len) {
			        case 1: listeners[i].fn.call(listeners[i].context); break;
			        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
			        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
			        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
			        default:
			          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
			            args[j - 1] = arguments[j];
			          }

			          listeners[i].fn.apply(listeners[i].context, args);
			      }
			    }
			  }

			  return true;
			};

			/**
			 * Add a listener for a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @param {Function} fn The listener function.
			 * @param {*} [context=this] The context to invoke the listener with.
			 * @returns {EventEmitter} `this`.
			 * @public
			 */
			EventEmitter.prototype.on = function on(event, fn, context) {
			  return addListener(this, event, fn, context, false);
			};

			/**
			 * Add a one-time listener for a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @param {Function} fn The listener function.
			 * @param {*} [context=this] The context to invoke the listener with.
			 * @returns {EventEmitter} `this`.
			 * @public
			 */
			EventEmitter.prototype.once = function once(event, fn, context) {
			  return addListener(this, event, fn, context, true);
			};

			/**
			 * Remove the listeners of a given event.
			 *
			 * @param {(String|Symbol)} event The event name.
			 * @param {Function} fn Only remove the listeners that match this function.
			 * @param {*} context Only remove the listeners that have this context.
			 * @param {Boolean} once Only remove one-time listeners.
			 * @returns {EventEmitter} `this`.
			 * @public
			 */
			EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
			  var evt = prefix ? prefix + event : event;

			  if (!this._events[evt]) return this;
			  if (!fn) {
			    clearEvent(this, evt);
			    return this;
			  }

			  var listeners = this._events[evt];

			  if (listeners.fn) {
			    if (
			      listeners.fn === fn &&
			      (!once || listeners.once) &&
			      (!context || listeners.context === context)
			    ) {
			      clearEvent(this, evt);
			    }
			  } else {
			    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
			      if (
			        listeners[i].fn !== fn ||
			        (once && !listeners[i].once) ||
			        (context && listeners[i].context !== context)
			      ) {
			        events.push(listeners[i]);
			      }
			    }

			    //
			    // Reset the array, or remove it completely if we have no more listeners.
			    //
			    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
			    else clearEvent(this, evt);
			  }

			  return this;
			};

			/**
			 * Remove all listeners, or those of the specified event.
			 *
			 * @param {(String|Symbol)} [event] The event name.
			 * @returns {EventEmitter} `this`.
			 * @public
			 */
			EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
			  var evt;

			  if (event) {
			    evt = prefix ? prefix + event : event;
			    if (this._events[evt]) clearEvent(this, evt);
			  } else {
			    this._events = new Events();
			    this._eventsCount = 0;
			  }

			  return this;
			};

			//
			// Alias methods names because people roll like that.
			//
			EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
			EventEmitter.prototype.addListener = EventEmitter.prototype.on;

			//
			// Expose the prefix.
			//
			EventEmitter.prefixed = prefix;

			//
			// Allow `EventEmitter` to be imported as module namespace.
			//
			EventEmitter.EventEmitter = EventEmitter;

			//
			// Expose the module.
			//
			{
			  module.exports = EventEmitter;
			} 
		} (eventemitter3));
		return eventemitter3.exports;
	}

	var hasRequiredAdapter$1;

	function requireAdapter$1 () {
		if (hasRequiredAdapter$1) return adapter;
		hasRequiredAdapter$1 = 1;
		var __importDefault = (adapter && adapter.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(adapter, "__esModule", { value: true });
		adapter.Adapter = adapter.AdapterState = adapter.WalletReadyState = adapter.EventEmitter = void 0;
		const eventemitter3_1 = __importDefault(requireEventemitter3());
		adapter.EventEmitter = eventemitter3_1.default;
		/**
		 * Wallet ready state.
		 */
		var WalletReadyState;
		(function (WalletReadyState) {
		    /**
		     * Adapter will start to check if wallet exists after adapter instance is created.
		     */
		    WalletReadyState["Loading"] = "Loading";
		    /**
		     * When checking ends and wallet is not found, readyState will be NotFound.
		     */
		    WalletReadyState["NotFound"] = "NotFound";
		    /**
		     * When checking ends and wallet is found, readyState will be Found.
		     */
		    WalletReadyState["Found"] = "Found";
		})(WalletReadyState || (adapter.WalletReadyState = WalletReadyState = {}));
		/**
		 * Adapter state
		 */
		var AdapterState;
		(function (AdapterState) {
		    /**
		     * If adapter is checking the wallet, the state is Loading.
		     */
		    AdapterState["Loading"] = "Loading";
		    /**
		     * If wallet is not installed, the state is NotFound.
		     */
		    AdapterState["NotFound"] = "NotFound";
		    /**
		     * If wallet is installed but is not connected to current Dapp, the state is Disconnected.
		     */
		    AdapterState["Disconnect"] = "Disconnected";
		    /**
		     * Wallet is connected to current Dapp.
		     */
		    AdapterState["Connected"] = "Connected";
		})(AdapterState || (adapter.AdapterState = AdapterState = {}));
		class Adapter extends eventemitter3_1.default {
		    get connected() {
		        return this.state === AdapterState.Connected;
		    }
		    /**
		     * Some wallets such as TronLink don't support disconnect() method.
		     */
		    disconnect() {
		        console.info("The current adapter doesn't support disconnect by DApp.");
		        return Promise.resolve();
		    }
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    multiSign(...args) {
		        return Promise.reject("The current wallet doesn't support multiSign.");
		    }
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    switchChain(_chainId) {
		        return Promise.reject("The current wallet doesn't support switch chain.");
		    }
		}
		adapter.Adapter = Adapter;
		
		return adapter;
	}

	var errors = {};

	var hasRequiredErrors;

	function requireErrors () {
		if (hasRequiredErrors) return errors;
		hasRequiredErrors = 1;
		Object.defineProperty(errors, "__esModule", { value: true });
		errors.WalletGetNetworkError = errors.WalletSwitchChainError = errors.WalletWindowClosedError = errors.WalletWalletLoadError = errors.WalletSignTransactionError = errors.WalletSignMessageError = errors.WalletDisconnectionError = errors.WalletConnectionError = errors.WalletDisconnectedError = errors.WalletNotSelectedError = errors.WalletNotFoundError = errors.WalletError = void 0;
		class WalletError extends Error {
		    constructor(message, error) {
		        super(message);
		        this.error = error;
		    }
		}
		errors.WalletError = WalletError;
		/**
		 * Occurs when wallet is not installed.
		 */
		class WalletNotFoundError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletNotFoundError';
		        this.message = 'The wallet is not found.';
		    }
		}
		errors.WalletNotFoundError = WalletNotFoundError;
		/**
		 * Occurs when connect to a wallet but there is no wallet selected.
		 */
		class WalletNotSelectedError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletNotSelectedError';
		        this.message = 'No wallet is selected. Please select a wallet.';
		    }
		}
		errors.WalletNotSelectedError = WalletNotSelectedError;
		/**
		 * Occurs when wallet is disconnected.
		 * Used by some wallets which won't connect automatically when call `signMessage()` or `signTransaction()`.
		 */
		class WalletDisconnectedError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletDisconnectedError';
		        this.message = 'The wallet is disconnected. Please connect first.';
		    }
		}
		errors.WalletDisconnectedError = WalletDisconnectedError;
		/**
		 * Occurs when try to connect a wallet.
		 */
		class WalletConnectionError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletConnectionError';
		    }
		}
		errors.WalletConnectionError = WalletConnectionError;
		/**
		 * Occurs when try to disconnect a wallet.
		 */
		class WalletDisconnectionError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletDisconnectionError';
		    }
		}
		errors.WalletDisconnectionError = WalletDisconnectionError;
		/**
		 * Occurs when call `signMessage()`.
		 */
		class WalletSignMessageError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletSignMessageError';
		    }
		}
		errors.WalletSignMessageError = WalletSignMessageError;
		/**
		 * Occurs when call `signTransaction()`.
		 */
		class WalletSignTransactionError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletSignTransactionError';
		    }
		}
		errors.WalletSignTransactionError = WalletSignTransactionError;
		/**
		 * Occurs when load wallet
		 */
		class WalletWalletLoadError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletWalletLoadError';
		    }
		}
		errors.WalletWalletLoadError = WalletWalletLoadError;
		/**
		 * Occurs when walletconnect QR window is closed.
		 */
		class WalletWindowClosedError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletWindowClosedError';
		        this.message = 'The QR window is closed.';
		    }
		}
		errors.WalletWindowClosedError = WalletWindowClosedError;
		/**
		 * Occurs when request wallet to switch chain.
		 */
		class WalletSwitchChainError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletSwitchChainError';
		    }
		}
		errors.WalletSwitchChainError = WalletSwitchChainError;
		/**
		 * Occurs when get network infomation.
		 */
		class WalletGetNetworkError extends WalletError {
		    constructor() {
		        super(...arguments);
		        this.name = 'WalletGetNetworkError';
		    }
		}
		errors.WalletGetNetworkError = WalletGetNetworkError;
		
		return errors;
	}

	var types = {};

	var hasRequiredTypes;

	function requireTypes () {
		if (hasRequiredTypes) return types;
		hasRequiredTypes = 1;
		Object.defineProperty(types, "__esModule", { value: true });
		types.ChainNetwork = types.NetworkType = void 0;
		var NetworkType;
		(function (NetworkType) {
		    NetworkType["Mainnet"] = "Mainnet";
		    NetworkType["Shasta"] = "Shasta";
		    NetworkType["Nile"] = "Nile";
		    /**
		     * When use custom node
		     */
		    NetworkType["Unknown"] = "Unknown";
		})(NetworkType || (types.NetworkType = NetworkType = {}));
		var ChainNetwork;
		(function (ChainNetwork) {
		    ChainNetwork["Mainnet"] = "Mainnet";
		    ChainNetwork["Shasta"] = "Shasta";
		    ChainNetwork["Nile"] = "Nile";
		})(ChainNetwork || (types.ChainNetwork = ChainNetwork = {}));
		
		return types;
	}

	var utils$1 = {};

	var hasRequiredUtils$1;

	function requireUtils$1 () {
		if (hasRequiredUtils$1) return utils$1;
		hasRequiredUtils$1 = 1;
		Object.defineProperty(utils$1, "__esModule", { value: true });
		utils$1.isInBrowser = isInBrowser;
		utils$1.checkAdapterState = checkAdapterState;
		utils$1.isInMobileBrowser = isInMobileBrowser;
		/**
		 * check simply if current environment is browser or not
		 * @returns boolean
		 */
		function isInBrowser() {
		    return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';
		}
		/**
		 *
		 * @param {Function} check funcion to check if wallet is installed. return true if wallet is detected.
		 * @returns
		 */
		function checkAdapterState(check) {
		    if (!isInBrowser())
		        return;
		    const disposers = [];
		    function dispose() {
		        for (const dispose of disposers) {
		            dispose();
		        }
		    }
		    function checkAndDispose() {
		        if (check()) {
		            dispose();
		        }
		    }
		    const interval = setInterval(checkAndDispose, 500);
		    disposers.push(() => clearInterval(interval));
		    if (document.readyState === 'loading') {
		        document.addEventListener('DOMContentLoaded', checkAndDispose, { once: true });
		        disposers.push(() => document.removeEventListener('DOMContentLoaded', checkAndDispose));
		    }
		    if (document.readyState !== 'complete') {
		        window.addEventListener('load', checkAndDispose, { once: true });
		        disposers.push(() => window.removeEventListener('load', checkAndDispose));
		    }
		    checkAndDispose();
		    // stop all task after 1min
		    setTimeout(dispose, 60 * 1000);
		}
		/**
		 * Simplily detect mobile device
		 */
		function isInMobileBrowser() {
		    return (typeof navigator !== 'undefined' &&
		        navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i));
		}
		
		return utils$1;
	}

	var hasRequiredCjs$1;

	function requireCjs$1 () {
		if (hasRequiredCjs$1) return cjs;
		hasRequiredCjs$1 = 1;
		(function (exports) {
			var __createBinding = (cjs && cjs.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (cjs && cjs.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			__exportStar(/*@__PURE__*/ requireAdapter$1(), exports);
			__exportStar(/*@__PURE__*/ requireErrors(), exports);
			__exportStar(/*@__PURE__*/ requireTypes(), exports);
			__exportStar(/*@__PURE__*/ requireUtils$1(), exports);
			
		} (cjs));
		return cjs;
	}

	var hasRequiredAdapter;

	function requireAdapter () {
		if (hasRequiredAdapter) return adapter$1;
		hasRequiredAdapter = 1;
		(function (exports) {
			var __awaiter = (adapter$1 && adapter$1.__awaiter) || function (thisArg, _arguments, P, generator) {
			    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
			    return new (P || (P = Promise))(function (resolve, reject) {
			        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
			        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
			        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
			        step((generator = generator.apply(thisArg, _arguments || [])).next());
			    });
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.BinanceWalletAdapter = exports.BinanceWalletAdapterName = void 0;
			const tronwallet_abstract_adapter_1 = /*@__PURE__*/ requireCjs$1();
			exports.BinanceWalletAdapterName = 'Binance Wallet';
			const chainIdNetworkMap = {
			    '0x2b6653dc': tronwallet_abstract_adapter_1.NetworkType.Mainnet,
			    '0x94a9059e': tronwallet_abstract_adapter_1.NetworkType.Shasta,
			    '0xcd8690dc': tronwallet_abstract_adapter_1.NetworkType.Nile,
			};
			class BinanceWalletAdapter extends tronwallet_abstract_adapter_1.Adapter {
			    constructor(config = {}) {
			        super();
			        this.name = exports.BinanceWalletAdapterName;
			        this.url = 'https://www.binance.com/en/binancewallet';
			        this.icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMEIwRTExIi8+CjxwYXRoIGQ9Ik01IDE1TDcuMjU4MDYgMTIuNzQxOUw5LjUxNjEzIDE1TDcuMjU4MDYgMTcuMjU4MUw1IDE1WiIgZmlsbD0iI0YwQjkwQiIvPgo8cGF0aCBkPSJNOC44NzA5NyAxMS4xMjlMMTUgNUwyMS4xMjkgMTEuMTI5TDE4Ljg3MSAxMy4zODcxTDE1IDkuNTE2MTNMMTEuMTI5IDEzLjM4NzFMOC44NzA5NyAxMS4xMjlaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0xMi43NDE5IDE1TDE1IDEyLjc0MTlMMTcuMjU4MSAxNUwxNSAxNy4yNTgxTDEyLjc0MTkgMTVaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0xMS4xMjkgMTYuNjEyOUw4Ljg3MDk3IDE4Ljg3MUwxNSAyNUwyMS4xMjkgMTguODcxTDE4Ljg3MSAxNi42MTI5TDE1IDIwLjQ4MzlMMTEuMTI5IDE2LjYxMjlaIiBmaWxsPSIjRjBCOTBCIi8+CjxwYXRoIGQ9Ik0yMC40ODM5IDE1TDIyLjc0MTkgMTIuNzQxOUwyNSAxNUwyMi43NDE5IDE3LjI1ODFMMjAuNDgzOSAxNVoiIGZpbGw9IiNGMEI5MEIiLz4KPC9zdmc+Cg==';
			        this._readyState = (0, tronwallet_abstract_adapter_1.isInBrowser)() ? tronwallet_abstract_adapter_1.WalletReadyState.Loading : tronwallet_abstract_adapter_1.WalletReadyState.NotFound;
			        this._state = tronwallet_abstract_adapter_1.AdapterState.Loading;
			        this._onAccountsChanged = (address) => {
			            const preAddr = this.address || '';
			            this.setAddress(address[0]);
			            this.emit('accountsChanged', this.address || '', preAddr);
			        };
			        this._checkPromise = null;
			        this._updateProvider = () => {
			            var _a;
			            let state = this.state;
			            let address = this.address;
			            if ((_a = window.binancew3w) === null || _a === void 0 ? void 0 : _a.tron) {
			                this._provider = window.binancew3w.tron;
			                address = null; // Will be set when connected
			                state = tronwallet_abstract_adapter_1.AdapterState.Disconnect;
			            }
			            else {
			                this._provider = null;
			                address = null;
			                state = tronwallet_abstract_adapter_1.AdapterState.NotFound;
			            }
			            this.setAddress(address);
			            this.setState(state);
			        };
			        const { checkTimeout = 2 * 1000, openUrlWhenWalletNotFound = true } = config;
			        if (typeof checkTimeout !== 'number') {
			            throw new Error('[BinanceWalletAdapter] config.checkTimeout should be a number');
			        }
			        this.config = {
			            checkTimeout,
			            openUrlWhenWalletNotFound,
			        };
			        this._connecting = false;
			        this._provider = null;
			        this._address = null;
			        if (!(0, tronwallet_abstract_adapter_1.isInBrowser)()) {
			            this._readyState = tronwallet_abstract_adapter_1.WalletReadyState.NotFound;
			            this.setState(tronwallet_abstract_adapter_1.AdapterState.NotFound);
			            return;
			        }
			        this._checkWallet().then(() => {
			            if (this.connected) {
			                this.emit('connect', this.address || '');
			                this._listenEvent();
			            }
			        });
			    }
			    get address() {
			        return this._address;
			    }
			    get state() {
			        return this._state;
			    }
			    get readyState() {
			        return this._readyState;
			    }
			    get connecting() {
			        return this._connecting;
			    }
			    /**
			     * Get network information used by Binance Wallet.
			     * @returns {Network} Current network information.
			     */
			    network() {
			        return __awaiter(this, void 0, void 0, function* () {
			            try {
			                yield this._checkWallet();
			                if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected)
			                    throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
			                try {
			                    const chainId = this._provider.getChainId();
			                    return {
			                        networkType: chainIdNetworkMap[chainId] || tronwallet_abstract_adapter_1.NetworkType.Unknown,
			                        chainId,
			                        fullNode: '',
			                        solidityNode: '',
			                        eventServer: '',
			                    };
			                }
			                catch (e) {
			                    throw new tronwallet_abstract_adapter_1.WalletGetNetworkError(e === null || e === void 0 ? void 0 : e.message, e);
			                }
			            }
			            catch (e) {
			                this.emit('error', e);
			                throw e;
			            }
			        });
			    }
			    connect() {
			        return __awaiter(this, void 0, void 0, function* () {
			            try {
			                if (this.connected || this.connecting)
			                    return;
			                yield this._checkWallet();
			                if (this.state === tronwallet_abstract_adapter_1.AdapterState.NotFound) {
			                    if (this.config.openUrlWhenWalletNotFound !== false && (0, tronwallet_abstract_adapter_1.isInBrowser)()) {
			                        window.open(this.url, '_blank');
			                    }
			                    throw new tronwallet_abstract_adapter_1.WalletNotFoundError();
			                }
			                this._connecting = true;
			                try {
			                    const { address } = yield this._provider.getAccount();
			                    this.setAddress(address);
			                    this.setState(tronwallet_abstract_adapter_1.AdapterState.Connected);
			                    this.emit('connect', address);
			                    this._listenEvent();
			                }
			                catch (error) {
			                    throw new tronwallet_abstract_adapter_1.WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);
			                }
			            }
			            catch (error) {
			                this.emit('error', error);
			                throw error;
			            }
			            finally {
			                this._connecting = false;
			            }
			        });
			    }
			    disconnect() {
			        return __awaiter(this, void 0, void 0, function* () {
			            if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected) {
			                return;
			            }
			            yield this._provider.disconnect();
			            this.setAddress(null);
			            this.setState(tronwallet_abstract_adapter_1.AdapterState.Disconnect);
			            this.emit('disconnect');
			            this._stopListenEvent();
			        });
			    }
			    signMessage(message) {
			        return __awaiter(this, void 0, void 0, function* () {
			            try {
			                if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected)
			                    throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
			                try {
			                    return yield this._provider.signMessageV2(message);
			                }
			                catch (error) {
			                    throw new tronwallet_abstract_adapter_1.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);
			                }
			            }
			            catch (error) {
			                this.emit('error', error);
			                throw error;
			            }
			        });
			    }
			    signTransaction(transaction) {
			        return __awaiter(this, void 0, void 0, function* () {
			            try {
			                if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected)
			                    throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
			                try {
			                    return yield this._provider.signTransaction(transaction);
			                }
			                catch (error) {
			                    throw new tronwallet_abstract_adapter_1.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
			                }
			            }
			            catch (error) {
			                this.emit('error', error);
			                throw error;
			            }
			        });
			    }
			    _listenEvent() {
			        this._stopListenEvent();
			        this._provider.on('accountsChanged', this._onAccountsChanged);
			    }
			    _stopListenEvent() {
			        this._provider.removeListener('accountsChanged', this._onAccountsChanged);
			    }
			    _checkWallet() {
			        return __awaiter(this, void 0, void 0, function* () {
			            if (this.readyState === tronwallet_abstract_adapter_1.WalletReadyState.Found) {
			                return true;
			            }
			            if (this._checkPromise) {
			                return this._checkPromise;
			            }
			            const interval = 100;
			            const maxTimes = Math.floor(this.config.checkTimeout / interval);
			            let times = 0;
			            let timer;
			            this._checkPromise = new Promise((resolve) => {
			                const check = () => {
			                    var _a;
			                    times++;
			                    const isSupport = !!((_a = window.binancew3w) === null || _a === void 0 ? void 0 : _a.tron);
			                    if (isSupport || times > maxTimes) {
			                        timer && clearInterval(timer);
			                        this._readyState = isSupport ? tronwallet_abstract_adapter_1.WalletReadyState.Found : tronwallet_abstract_adapter_1.WalletReadyState.NotFound;
			                        this._updateProvider();
			                        this.emit('readyStateChanged', this.readyState);
			                        resolve(isSupport);
			                    }
			                };
			                timer = setInterval(check, interval);
			                check();
			            });
			            return this._checkPromise;
			        });
			    }
			    setAddress(address) {
			        this._address = address;
			    }
			    setState(state) {
			        const preState = this.state;
			        if (state !== preState) {
			            this._state = state;
			            this.emit('stateChanged', state);
			        }
			    }
			}
			exports.BinanceWalletAdapter = BinanceWalletAdapter;
			
		} (adapter$1));
		return adapter$1;
	}

	var utils = {};

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils;
		hasRequiredUtils = 1;
		Object.defineProperty(utils, "__esModule", { value: true });
		utils.supportBinanceWallet = supportBinanceWallet;
		utils.openBinanceWallet = openBinanceWallet;
		const w3w_utils_1 = require$$0;
		const tronwallet_abstract_adapter_1 = /*@__PURE__*/ requireCjs$1();
		function supportBinanceWallet() {
		    return (0, tronwallet_abstract_adapter_1.isInBrowser)() && Boolean(window.isBinance);
		}
		function openBinanceWallet() {
		    if ((0, tronwallet_abstract_adapter_1.isInMobileBrowser)() && !supportBinanceWallet()) {
		        window.location.href = (0, w3w_utils_1.getDeepLink)(window.location.href).bnc;
		        return true;
		    }
		    return false;
		}
		
		return utils;
	}

	var hasRequiredCjs;

	function requireCjs () {
		if (hasRequiredCjs) return cjs$1;
		hasRequiredCjs = 1;
		(function (exports) {
			var __createBinding = (cjs$1 && cjs$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    var desc = Object.getOwnPropertyDescriptor(m, k);
			    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			      desc = { enumerable: true, get: function() { return m[k]; } };
			    }
			    Object.defineProperty(o, k2, desc);
			}) : (function(o, m, k, k2) {
			    if (k2 === undefined) k2 = k;
			    o[k2] = m[k];
			}));
			var __exportStar = (cjs$1 && cjs$1.__exportStar) || function(m, exports) {
			    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			__exportStar(/*@__PURE__*/ requireAdapter(), exports);
			__exportStar(/*@__PURE__*/ requireUtils(), exports);
			
		} (cjs$1));
		return cjs$1;
	}

	var cjsExports = requireCjs();
	var index = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

	return index;

}));
