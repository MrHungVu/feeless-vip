"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitKeepAdapter = exports.BitgetWalletAdapterName = void 0;
const tronwallet_abstract_adapter_1 = require("@tronweb3/tronwallet-abstract-adapter");
const tronwallet_adapter_tronlink_1 = require("@tronweb3/tronwallet-adapter-tronlink");
const utils_js_1 = require("./utils.js");
exports.BitgetWalletAdapterName = 'Bitget Wallet';
class BitKeepAdapter extends tronwallet_abstract_adapter_1.Adapter {
    constructor(config = {}) {
        super();
        this.name = exports.BitgetWalletAdapterName;
        this.url = 'https://web3.bitget.com';
        this.icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDAxRjI5Ii8+CjxwYXRoIGQ9Ik0yMTkuOTQ4IDk1LjcwMjJDMjAxLjYyMyA5NS42OTI5IDE4My4zMyA5NS42ODM1IDE2NC45NDEgOTUuNzExNkMxNTMuODIyIDk1LjcxMTYgMTQ5LjY1MSAxMDkuNjcxIDE1Ny45MjEgMTE3LjkzOUwyODMuMDk4IDI0My4xMTdDMjg3LjAwNCAyNDYuNjkgMjg5LjQ0MSAyNTAuNTc0IDI4OS41MyAyNTUuNjkzQzI4OS40NDEgMjYwLjgxMiAyODcuMDA0IDI2NC42OTYgMjgzLjA5OCAyNjguMjY5TDE1Ny45MjEgMzkzLjQ0NkMxNDkuNjUxIDQwMS43MTUgMTUzLjgyMiA0MTUuNjc0IDE2NC45NDEgNDE1LjY3NEMxODMuMzMgNDE1LjcwMiAyMDEuNjIzIDQxNS42OTMgMjE5Ljk0OCA0MTUuNjgzQzIyOS4xMjIgNDE1LjY3OSAyMzguMzA1IDQxNS42NzQgMjQ3LjUxMSA0MTUuNjc0QzI1OS41NTUgNDE1LjY3NCAyNjYuNzIgNDA5LjI0IDI3My4xNTQgNDAyLjgwNUwzODYuMDQ3IDI4OS45MTJDMzk1LjA1NyAyODAuOTAyIDQwMy4xMTkgMjY4LjkzOSA0MDMuMDA5IDI1NS42OTNDNDAzLjExOSAyNDIuNDQ3IDM5NS4wNTcgMjMwLjQ4NCAzODYuMDQ3IDIyMS40NzRMMjczLjE1NCAxMDguNThDMjY2LjcyIDEwMi4xNDYgMjU5LjU1NSA5NS43MTE2IDI0Ny41MTEgOTUuNzExNkMyMzguMzA1IDk1LjcxMTYgMjI5LjEyMiA5NS43MDY5IDIxOS45NDggOTUuNzAyMloiIGZpbGw9IiMwMEYwRkYiLz4KPC9zdmc+Cg==';
        this._readyState = tronwallet_abstract_adapter_1.WalletReadyState.Loading;
        this._state = tronwallet_abstract_adapter_1.AdapterState.Loading;
        this.checkReadyInterval = null;
        this._checkPromise = null;
        this._updateWallet = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f;
            let state = this.state;
            let address = this.address;
            if ((0, utils_js_1.supportBitgetWallet)()) {
                if ((0, tronwallet_abstract_adapter_1.isInMobileBrowser)()) {
                    const tron = (_a = window.bitkeep) === null || _a === void 0 ? void 0 : _a.tronLink;
                    this._wallet = {
                        tron,
                        tronWeb: tron === null || tron === void 0 ? void 0 : tron.tronWeb,
                    };
                }
                else {
                    const tronWeb = (_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.tronWeb;
                    this._wallet = {
                        tron: window.bitkeep.tronLink,
                        tronWeb,
                    };
                }
                address = ((_c = this._wallet.tron) === null || _c === void 0 ? void 0 : _c.ready) ? ((_d = this._wallet.tronWeb.defaultAddress) === null || _d === void 0 ? void 0 : _d.base58) || null : '';
                state = ((_e = this._wallet.tron) === null || _e === void 0 ? void 0 : _e.ready) ? tronwallet_abstract_adapter_1.AdapterState.Connected : tronwallet_abstract_adapter_1.AdapterState.Disconnect;
                if (!((_f = this._wallet.tron) === null || _f === void 0 ? void 0 : _f.ready)) {
                    this.checkForWalletReady();
                }
            }
            else {
                this._wallet = null;
                address = null;
                state = tronwallet_abstract_adapter_1.AdapterState.NotFound;
            }
            this.setAddress(address);
            this.setState(state);
        });
        const { checkTimeout = 2 * 1000, openUrlWhenWalletNotFound = true, openAppWithDeeplink = true } = config;
        if (typeof checkTimeout !== 'number') {
            throw new Error('[BitKeepAdapter] config.checkTimeout should be a number');
        }
        this.config = {
            checkTimeout,
            openUrlWhenWalletNotFound,
            openAppWithDeeplink,
        };
        this._connecting = false;
        this._wallet = null;
        this._address = null;
        if (!(0, tronwallet_abstract_adapter_1.isInBrowser)()) {
            this._readyState = tronwallet_abstract_adapter_1.WalletReadyState.NotFound;
            this.setState(tronwallet_abstract_adapter_1.AdapterState.NotFound);
            return;
        }
        if ((0, utils_js_1.supportBitgetWallet)()) {
            this._readyState = tronwallet_abstract_adapter_1.WalletReadyState.Found;
            this._updateWallet();
        }
        else {
            this._checkWallet().then(() => {
                if (this.connected) {
                    this.emit('connect', this.address || '');
                }
            });
        }
    }
    get address() {
        return this._address;
    }
    get state() {
        return this._state;
    }
    get readyState() {
        return this._readyState;
    }
    get connecting() {
        return this._connecting;
    }
    /**
     * Get network information.
     * @returns {Network} Current network information.
     */
    network() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._checkWallet();
                if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected)
                    throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
                const wallet = this._wallet;
                if (!wallet || !wallet.tronWeb)
                    throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
                try {
                    return yield (0, tronwallet_adapter_tronlink_1.getNetworkInfoByTronWeb)(wallet.tronWeb);
                }
                catch (e) {
                    throw new tronwallet_abstract_adapter_1.WalletGetNetworkError(e === null || e === void 0 ? void 0 : e.message, e);
                }
            }
            catch (e) {
                this.emit('error', e);
                throw e;
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            try {
                this.checkIfOpenApp();
                if (this.connected || this.connecting)
                    return;
                yield this._checkWallet();
                if (this.readyState === tronwallet_abstract_adapter_1.WalletReadyState.NotFound) {
                    if (this.config.openUrlWhenWalletNotFound !== false && (0, tronwallet_abstract_adapter_1.isInBrowser)()) {
                        window.open(this.url, '_blank');
                    }
                    throw new tronwallet_abstract_adapter_1.WalletNotFoundError();
                }
                const wallet = this._wallet;
                if (!(0, tronwallet_abstract_adapter_1.isInMobileBrowser)()) {
                    if (!wallet)
                        return;
                    this._connecting = true;
                    try {
                        const res = yield wallet.tron.request({ method: 'tron_requestAccounts' });
                        if ((res === null || res === void 0 ? void 0 : res.code) !== 200) {
                            throw new tronwallet_abstract_adapter_1.WalletConnectionError(
                            // @ts-ignore
                            (res === null || res === void 0 ? void 0 : res.code) === 40001 ? 'The connection request is canceled by user.' : res === null || res === void 0 ? void 0 : res.message);
                        }
                    }
                    catch (e) {
                        if (e instanceof tronwallet_abstract_adapter_1.WalletError) {
                            throw e;
                        }
                        else {
                            throw new tronwallet_abstract_adapter_1.WalletConnectionError(e === null || e === void 0 ? void 0 : e.message, e);
                        }
                    }
                }
                const address = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.tronWeb.defaultAddress) === null || _a === void 0 ? void 0 : _a.base58) || ((_d = (_c = (_b = window.bitkeep) === null || _b === void 0 ? void 0 : _b.tronWeb) === null || _c === void 0 ? void 0 : _c.defaultAddress) === null || _d === void 0 ? void 0 : _d.base58) || '';
                this.setAddress(address);
                this.setState(tronwallet_abstract_adapter_1.AdapterState.Connected);
                this.emit('connect', this.address || '');
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
            finally {
                this._connecting = false;
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== tronwallet_abstract_adapter_1.AdapterState.Connected) {
                return;
            }
            this.setAddress(null);
            this.setState(tronwallet_abstract_adapter_1.AdapterState.Disconnect);
            this.emit('disconnect');
        });
    }
    signTransaction(transaction, privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const wallet = yield this.checkAndGetWallet();
                try {
                    return yield wallet.tronWeb.trx.sign(transaction, privateKey);
                }
                catch (error) {
                    if (error instanceof Error) {
                        throw new tronwallet_abstract_adapter_1.WalletSignTransactionError(error.message, error);
                    }
                    else {
                        throw new tronwallet_abstract_adapter_1.WalletSignTransactionError(error, new Error(error));
                    }
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
        });
    }
    multiSign(transaction, privateKey, permissionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const wallet = yield this.checkAndGetWallet();
                try {
                    return yield wallet.tronWeb.trx.multiSign(transaction, privateKey, permissionId);
                }
                catch (error) {
                    if (error instanceof Error) {
                        throw new tronwallet_abstract_adapter_1.WalletSignTransactionError(error.message, error);
                    }
                    else {
                        throw new tronwallet_abstract_adapter_1.WalletSignTransactionError(error, new Error(error));
                    }
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
        });
    }
    signMessage(message, privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const wallet = yield this.checkAndGetWallet();
                try {
                    return yield wallet.tronWeb.trx.signMessageV2(message, privateKey);
                }
                catch (error) {
                    if (error instanceof Error) {
                        throw new tronwallet_abstract_adapter_1.WalletSignMessageError(error.message, error);
                    }
                    else {
                        throw new tronwallet_abstract_adapter_1.WalletSignMessageError(error, new Error(error));
                    }
                }
            }
            catch (error) {
                this.emit('error', error);
                throw error;
            }
        });
    }
    checkAndGetWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkIfOpenApp();
            yield this._checkWallet();
            if (!this.connected)
                throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
            const wallet = this._wallet;
            if (!wallet || !wallet.tronWeb)
                throw new tronwallet_abstract_adapter_1.WalletDisconnectedError();
            return wallet;
        });
    }
    checkForWalletReady() {
        if (this.checkReadyInterval) {
            return;
        }
        let times = 0;
        const maxTimes = Math.floor(this.config.checkTimeout / 200);
        const check = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this._wallet && ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.tron.ready)) {
                this.checkReadyInterval && clearInterval(this.checkReadyInterval);
                this.checkReadyInterval = null;
                yield this._updateWallet();
                this.emit('connect', this.address || '');
            }
            else if (times > maxTimes) {
                this.checkReadyInterval && clearInterval(this.checkReadyInterval);
                this.checkReadyInterval = null;
            }
            else {
                times++;
            }
        });
        this.checkReadyInterval = setInterval(check, 200);
    }
    /**
     * check if wallet exists by interval, the promise only resolve when wallet detected or timeout
     * @returns if wallet exists
     */
    _checkWallet() {
        if (this.readyState === tronwallet_abstract_adapter_1.WalletReadyState.Found) {
            return Promise.resolve(true);
        }
        if (this._checkPromise) {
            return this._checkPromise;
        }
        const interval = 100;
        const maxTimes = Math.floor(this.config.checkTimeout / interval);
        let times = 0, timer;
        this._checkPromise = new Promise((resolve) => {
            const check = () => {
                times++;
                const isSupport = (0, utils_js_1.supportBitgetWallet)();
                if (isSupport || times > maxTimes) {
                    timer && clearInterval(timer);
                    this._readyState = isSupport ? tronwallet_abstract_adapter_1.WalletReadyState.Found : tronwallet_abstract_adapter_1.WalletReadyState.NotFound;
                    this._updateWallet();
                    this.emit('readyStateChanged', this.readyState);
                    resolve(isSupport);
                }
            };
            timer = setInterval(check, interval);
            check();
        });
        return this._checkPromise;
    }
    checkIfOpenApp() {
        if (this.config.openAppWithDeeplink === false) {
            return;
        }
        if ((0, utils_js_1.openBitgetWallet)()) {
            throw new tronwallet_abstract_adapter_1.WalletNotFoundError();
        }
    }
    setAddress(address) {
        this._address = address;
    }
    setState(state) {
        const preState = this.state;
        if (state !== preState) {
            this._state = state;
            this.emit('stateChanged', state);
        }
    }
}
exports.BitKeepAdapter = BitKeepAdapter;
//# sourceMappingURL=adapter.js.map