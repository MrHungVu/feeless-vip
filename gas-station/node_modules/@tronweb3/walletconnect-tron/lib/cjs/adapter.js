"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectWallet = exports.WalletConnectMethods = void 0;
const appkit_1 = require("@reown/appkit");
const universal_provider_1 = require("@walletconnect/universal-provider");
const utils_1 = require("@walletconnect/utils");
const errors_js_1 = require("./errors.js");
const utils_js_1 = require("./utils.js");
var WalletConnectMethods;
(function (WalletConnectMethods) {
    WalletConnectMethods["signTransaction"] = "tron_signTransaction";
    WalletConnectMethods["signMessage"] = "tron_signMessage";
})(WalletConnectMethods = exports.WalletConnectMethods || (exports.WalletConnectMethods = {}));
const getConnectParams = (chainId, pairingTopic) => ({
    requiredNamespaces: {
        tron: {
            chains: [chainId],
            methods: [WalletConnectMethods.signTransaction, WalletConnectMethods.signMessage],
            events: []
        }
    },
    pairingTopic: pairingTopic
});
class WalletConnectWallet {
    constructor(config) {
        this.providerPromise = null;
        this.eventListeners = new Map();
        this.sessionHandlers = {};
        this.modalStateUnsubscribers = [];
        this.eventUnsubscribers = [];
        // Cache subscription requests before AppKit is created
        this.pendingModalCallbacks = [];
        this.pendingEventCallbacks = [];
        this._options = config.options;
        this._network = config.network;
        this._config = config;
    }
    getProvider() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.provider)
                return this.provider;
            if (!this.providerPromise) {
                const projectId = this._options.projectId;
                if (!projectId) {
                    throw new Error('[WalletConnectWallet] projectId is required to initialize UniversalProvider');
                }
                this.providerPromise = universal_provider_1.UniversalProvider.init({
                    projectId: projectId,
                    logger: (_a = this._options) === null || _a === void 0 ? void 0 : _a.logger,
                    relayUrl: (_b = this._options) === null || _b === void 0 ? void 0 : _b.relayUrl,
                    metadata: (_c = this._options) === null || _c === void 0 ? void 0 : _c.metadata
                }).catch(error => {
                    // Reset providerPromise on failure to allow retry
                    this.providerPromise = null;
                    throw error;
                });
            }
            const provider = yield this.providerPromise;
            this.provider = provider;
            this._client = provider.client;
            return provider;
        });
    }
    extractAddressFromSession(session) {
        const accounts = Object.values(session.namespaces).flatMap(namespace => namespace.accounts);
        const account = accounts[0];
        if (!account) {
            throw new Error('[WalletConnectWallet] No accounts found in session');
        }
        // Account format: chainId:namespace:address (e.g., "tron:0x2b6653dc:Txxxxxxxxxxxxxxx")
        const address = account.split(':')[2];
        if (!address) {
            throw new Error(`[WalletConnectWallet] Invalid account format: ${account}`);
        }
        return address;
    }
    extractAllAddressesFromSession(session) {
        const accounts = Object.values(session.namespaces).flatMap(namespace => namespace.accounts);
        if (!accounts || accounts.length === 0) {
            return [];
        }
        // Account format: chainId:namespace:address (e.g., "tron:0x2b6653dc:Txxxxxxxxxxxxxxx")
        return accounts.map(account => account.split(':')[2]).filter((addr) => !!addr);
    }
    emit(event, ...args) {
        var _a;
        (_a = this.eventListeners.get(event)) === null || _a === void 0 ? void 0 : _a.forEach(listener => {
            try {
                listener(...args);
            }
            catch (error) {
                console.error(`[WalletConnectWallet] Error in ${event} listener:`, error);
            }
        });
    }
    on(event, listener) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, new Set());
        }
        this.eventListeners.get(event).add(listener);
        return () => this.off(event, listener);
    }
    off(event, listener) {
        var _a;
        (_a = this.eventListeners.get(event)) === null || _a === void 0 ? void 0 : _a.delete(listener);
    }
    removeAllListeners(event) {
        if (event) {
            this.eventListeners.delete(event);
        }
        else {
            this.eventListeners.clear();
        }
    }
    setupSessionListeners() {
        if (!this._client || !this._session)
            return;
        const cleanup = () => {
            if (this._client) {
                this.sessionHandlers.update && this._client.off('session_update', this.sessionHandlers.update);
                this.sessionHandlers.delete && this._client.off('session_delete', this.sessionHandlers.delete);
            }
            this.sessionHandlers = {};
        };
        cleanup();
        this.sessionHandlers.update = ({ topic, params }) => {
            var _a;
            if (!this._session || this._session.topic !== topic)
                return;
            let updated;
            try {
                updated = (_a = this._client) === null || _a === void 0 ? void 0 : _a.session.get(topic);
            }
            catch (_) {
                // Session was already removed; ignore late update
                return;
            }
            if (!updated)
                return;
            const oldAddresses = this.extractAllAddressesFromSession(this._session);
            this._session = Object.assign(Object.assign({}, updated), { namespaces: (params === null || params === void 0 ? void 0 : params.namespaces) || updated.namespaces });
            this.address = this.extractAddressFromSession(this._session);
            const newAddresses = this.extractAllAddressesFromSession(this._session);
            const addressesChanged = JSON.stringify(oldAddresses) !== JSON.stringify(newAddresses);
            if (addressesChanged) {
                this.emit('accountsChanged', newAddresses);
            }
        };
        this.sessionHandlers.delete = ({ topic }) => {
            var _a;
            if (((_a = this._session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {
                this._session = undefined;
                this.address = undefined;
                this.emit('disconnect');
                cleanup();
            }
        };
        this._client.on('session_update', this.sessionHandlers.update);
        this._client.on('session_delete', this.sessionHandlers.delete);
    }
    setupModalListeners() {
        if (!this.appKit)
            return;
        // Clean up existing subscriptions
        while (this.modalStateUnsubscribers.length > 0) {
            const unsubscribe = this.modalStateUnsubscribers.shift();
            unsubscribe();
        }
        // Clean up existing event subscriptions
        while (this.eventUnsubscribers.length > 0) {
            const unsubscribe = this.eventUnsubscribers.shift();
            unsubscribe();
        }
        // Process cached modal state subscriptions
        while (this.pendingModalCallbacks.length > 0) {
            const item = this.pendingModalCallbacks.shift();
            const unsubscribe = this.appKit.subscribeState(item.callback);
            this.modalStateUnsubscribers.push(unsubscribe);
            // Wire up the user's unsubscribe reference
            item.unsubscribeRef.fn = unsubscribe;
        }
        // Process cached event subscriptions
        while (this.pendingEventCallbacks.length > 0) {
            const item = this.pendingEventCallbacks.shift();
            const unsubscribe = this.appKit.subscribeEvents(item.callback);
            this.eventUnsubscribers.push(unsubscribe);
            // Wire up the user's unsubscribe reference
            item.unsubscribeRef.fn = unsubscribe;
        }
    }
    connect() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const client = provider.client;
            const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);
            if (sessions.length) {
                // select last matching session
                this._session = sessions[sessions.length - 1];
                // We assign this variable only after we're sure we've received approval
                this._client = client;
                this.address = this.extractAddressFromSession(this._session);
                this.setupSessionListeners();
                const addresses = this.extractAllAddressesFromSession(this._session);
                this.emit('accountsChanged', addresses);
                return {
                    address: this.address
                };
            }
            else {
                if (!this.appKit) {
                    // Extract known configuration properties
                    const _b = this._config, { network, options, themeMode, themeVariables, allWallets, featuredWalletIds, includeWalletIds, excludeWalletIds, customWallets, enableAnalytics, debug } = _b, extraAppKitConfig = __rest(_b, ["network", "options", "themeMode", "themeVariables", "allWallets", "featuredWalletIds", "includeWalletIds", "excludeWalletIds", "customWallets", "enableAnalytics", "debug"]) // Spread any additional AppKit config
                    ;
                    const selectedNetwork = utils_js_1.NETWORK_MAP.get(this._network);
                    this.appKit = (0, appkit_1.createAppKit)(Object.assign({ projectId: this._options.projectId, networks: [utils_js_1.mainnet, utils_js_1.nileTestnet, utils_js_1.shastaTestnet], defaultNetwork: selectedNetwork, themeMode,
                        themeVariables, allWallets: allWallets !== null && allWallets !== void 0 ? allWallets : 'HIDE', featuredWalletIds,
                        includeWalletIds,
                        excludeWalletIds,
                        customWallets,
                        enableAnalytics,
                        debug, manualWCControl: true, universalProvider: provider }, extraAppKitConfig // Spread extra config options
                    ));
                    this.setupModalListeners();
                } // Auto-setup modal event listeners
                yield this.appKit.open();
                try {
                    let isConnected = false;
                    let modalStateUnsubscribe;
                    // Monitor modal close to abort connection if user closes it
                    const connectPromise = provider.connect({
                        pairingTopic: undefined,
                        optionalNamespaces: getConnectParams(this._network).requiredNamespaces
                    });
                    // Create a promise that rejects when modal is closed by user (before connection completes)
                    const modalClosePromise = new Promise((_, reject) => {
                        let isModalOpen = true;
                        modalStateUnsubscribe = this.appKit.subscribeState(state => {
                            // Detect modal closing before connection is established
                            if (isModalOpen && !state.open && !isConnected) {
                                // Don't delete proposals - just reject to inform dApp
                                // If wallet confirms later, it will still work through session events
                                reject(new Error('User closed the connection modal'));
                            }
                            isModalOpen = state.open;
                        });
                    });
                    // Race between connection completing and modal being closed
                    const session = yield Promise.race([
                        connectPromise.then(result => {
                            isConnected = true; // Mark connection as successful
                            return result;
                        }),
                        modalClosePromise
                    ]).finally(() => {
                        // Clean up modal state subscription
                        modalStateUnsubscribe === null || modalStateUnsubscribe === void 0 ? void 0 : modalStateUnsubscribe();
                    });
                    this._session = session;
                    this._client = client;
                    this.address = this.extractAddressFromSession(this._session);
                    this.setupSessionListeners();
                    const addresses = this.extractAllAddressesFromSession(this._session);
                    this.emit('accountsChanged', addresses);
                    return { address: this.address };
                }
                catch (error) {
                    throw error;
                }
                finally {
                    yield ((_a = this.appKit) === null || _a === void 0 ? void 0 : _a.close());
                }
            }
        });
    }
    disconnect() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Clean up session handlers
                if (this._client) {
                    this.sessionHandlers.update && this._client.off('session_update', this.sessionHandlers.update);
                    this.sessionHandlers.delete && this._client.off('session_delete', this.sessionHandlers.delete);
                    this.sessionHandlers = {};
                }
                // Cleanup modal listeners
                while (this.modalStateUnsubscribers.length > 0) {
                    const unsubscribe = this.modalStateUnsubscribers.shift();
                    unsubscribe();
                }
                // Cleanup event subscriptions
                while (this.eventUnsubscribers.length > 0) {
                    const unsubscribe = this.eventUnsubscribers.shift();
                    unsubscribe();
                }
                const reason = (0, utils_1.getSdkError)('USER_DISCONNECTED');
                const topic = ((_a = this._session) === null || _a === void 0 ? void 0 : _a.topic) || ((_c = (_b = this.provider) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.topic);
                if (!topic)
                    throw new errors_js_1.ClientNotInitializedError();
                const client = ((_d = this.provider) === null || _d === void 0 ? void 0 : _d.client) || this._client;
                if (!client)
                    throw new errors_js_1.ClientNotInitializedError();
                yield client.disconnect({ topic, reason });
            }
            finally {
                // Always clean up session and address, even if disconnect fails
                this._session = undefined;
                this.address = undefined;
            }
        });
    }
    get client() {
        if (this._client)
            return this._client;
        throw new errors_js_1.ClientNotInitializedError();
    }
    checkConnectStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const client = provider.client;
            const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);
            if (sessions.length) {
                // select last matching session
                this._session = sessions[sessions.length - 1];
                // We assign this variable only after we're sure we've received approval
                this._client = client;
                this.address = this.extractAddressFromSession(this._session);
                this.setupSessionListeners();
                const addresses = this.extractAllAddressesFromSession(this._session);
                this.emit('accountsChanged', addresses);
                return {
                    address: this.address
                };
            }
            else {
                return {
                    address: ''
                };
            }
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._client && this._session) {
                const sessionProperties = this._session.sessionProperties;
                const isV1Method = (sessionProperties === null || sessionProperties === void 0 ? void 0 : sessionProperties.tron_method_version) === 'v1';
                const result = yield this._client.request({
                    chainId: this._network,
                    topic: this._session.topic,
                    request: {
                        method: WalletConnectMethods.signTransaction,
                        params: isV1Method
                            ? {
                                address: this.address,
                                transaction
                            }
                            : {
                                address: this.address,
                                transaction: { transaction }
                            }
                    }
                });
                return (result === null || result === void 0 ? void 0 : result.result) ? result.result : result;
            }
            else {
                throw new errors_js_1.ClientNotInitializedError();
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._client && this._session) {
                const { signature } = yield this._client.request({
                    chainId: this._network,
                    topic: this._session.topic,
                    request: {
                        method: WalletConnectMethods.signMessage,
                        params: {
                            address: this.address,
                            message
                        }
                    }
                });
                return signature;
            }
            else {
                throw new errors_js_1.ClientNotInitializedError();
            }
        });
    }
    // ========== AppKit Method Pass-through ==========
    // The following methods expose AppKit functionality in manualWCControl mode.
    // Note: AppKit instance is created during the first connect() call.
    /**
     * Close the AppKit modal.
     * @throws {Error} If AppKit is not initialized
     */
    closeModal() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.appKit) {
                throw new Error('[WalletConnectWallet] AppKit not initialized. Please call connect() first.');
            }
            yield this.appKit.close();
        });
    }
    /**
     * Set the theme mode (light or dark).
     * @param mode - 'light' or 'dark'
     * @throws {Error} If AppKit is not initialized
     */
    setThemeMode(mode) {
        if (!this.appKit) {
            throw new Error('[WalletConnectWallet] AppKit not initialized. Please call connect() first.');
        }
        this.appKit.setThemeMode(mode);
    }
    /**
     * Subscribe to AppKit modal state changes.
     * @param callback - Callback function called when state changes
     * @returns Unsubscribe function
     * @note Can be called before connect(). Subscription will be active after AppKit is initialized.
     */
    subscribeModalState(callback) {
        if (!this.appKit) {
            // AppKit not created yet, cache the callback with an unsubscribe reference
            const unsubscribeRef = {};
            const item = { callback, unsubscribeRef };
            this.pendingModalCallbacks.push(item);
            // Return cleanup function that works both before and after AppKit initialization
            return () => {
                if (unsubscribeRef.fn) {
                    // AppKit already initialized, call the real unsubscribe
                    unsubscribeRef.fn();
                    // Remove from array
                    const index = this.modalStateUnsubscribers.indexOf(unsubscribeRef.fn);
                    if (index > -1) {
                        this.modalStateUnsubscribers.splice(index, 1);
                    }
                }
                else {
                    // AppKit not yet initialized, remove from pending
                    const index = this.pendingModalCallbacks.indexOf(item);
                    if (index > -1) {
                        this.pendingModalCallbacks.splice(index, 1);
                    }
                }
            };
        }
        // AppKit already exists, subscribe immediately
        const unsubscribe = this.appKit.subscribeState(callback);
        this.modalStateUnsubscribers.push(unsubscribe);
        return () => {
            unsubscribe();
            const index = this.modalStateUnsubscribers.indexOf(unsubscribe);
            if (index > -1) {
                this.modalStateUnsubscribers.splice(index, 1);
            }
        };
    }
    /**
     * Subscribe to all AppKit events.
     * @param callback - Callback function called on each event
     * @returns Unsubscribe function
     * @note Can be called before connect(). Subscription will be active after AppKit is initialized.
     */
    subscribeEvents(callback) {
        if (!this.appKit) {
            // AppKit not created yet, cache the callback with an unsubscribe reference
            const unsubscribeRef = {};
            const item = { callback, unsubscribeRef };
            this.pendingEventCallbacks.push(item);
            // Return cleanup function that works both before and after AppKit initialization
            return () => {
                if (unsubscribeRef.fn) {
                    // AppKit already initialized, call the real unsubscribe
                    unsubscribeRef.fn();
                    // Remove from array
                    const index = this.eventUnsubscribers.indexOf(unsubscribeRef.fn);
                    if (index > -1) {
                        this.eventUnsubscribers.splice(index, 1);
                    }
                }
                else {
                    // AppKit not yet initialized, remove from pending
                    const index = this.pendingEventCallbacks.indexOf(item);
                    if (index > -1) {
                        this.pendingEventCallbacks.splice(index, 1);
                    }
                }
            };
        }
        // AppKit already exists, subscribe immediately
        const unsubscribe = this.appKit.subscribeEvents(callback);
        this.eventUnsubscribers.push(unsubscribe);
        return () => {
            unsubscribe();
            const index = this.eventUnsubscribers.indexOf(unsubscribe);
            if (index > -1) {
                this.eventUnsubscribers.splice(index, 1);
            }
        };
    }
}
exports.WalletConnectWallet = WalletConnectWallet;
//# sourceMappingURL=adapter.js.map