{
  "version": 3,
  "sources": ["../../../../node_modules/@ledgerhq/hw-transport/src/Transport.ts"],
  "sourcesContent": ["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],
  "mappings": "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",
  "names": ["EventEmitter"]
}
