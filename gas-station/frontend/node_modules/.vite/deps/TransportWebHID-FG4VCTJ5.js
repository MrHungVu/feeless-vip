import {
  Transport
} from "./chunk-M4J34DBV.js";
import {
  require_semver
} from "./chunk-2RHGYRSM.js";
import {
  DisconnectedDevice,
  DisconnectedDeviceDuringOperation,
  TransportError,
  TransportOpenUserCancelled,
  init_lib_es,
  log
} from "./chunk-XAVRVGNV.js";
import "./chunk-P462YRXK.js";
import {
  __publicField,
  __toESM
} from "./chunk-256EKJAK.js";

// ../node_modules/@ledgerhq/devices/lib-es/hid-framing.js
init_lib_es();
var Tag = 5;
function asUInt16BE(value) {
  const b = Buffer.alloc(2);
  b.writeUInt16BE(value, 0);
  return b;
}
var initialAcc = {
  data: Buffer.alloc(0),
  dataLength: 0,
  sequence: 0
};
var createHIDframing = (channel, packetSize) => {
  return {
    /**
     * Frames/encodes an APDU message into HID USB packets/frames
     *
     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]
     * @returns an array of HID USB frames ready to be sent
     */
    makeBlocks(apdu) {
      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);
      const blockSize = packetSize - 5;
      const nbBlocks = Math.ceil(data.length / blockSize);
      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);
      const blocks = [];
      for (let i = 0; i < nbBlocks; i++) {
        const head = Buffer.alloc(5);
        head.writeUInt16BE(channel, 0);
        head.writeUInt8(Tag, 2);
        head.writeUInt16BE(i, 3);
        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
        blocks.push(Buffer.concat([head, chunk]));
      }
      return blocks;
    },
    /**
     * Reduces HID USB packets/frames to one response.
     *
     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.
     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.
     * @param chunk Current chunk to reduce into accumulator
     * @returns An accumulator value updated with the current chunk
     */
    reduceResponse(acc, chunk) {
      let { data, dataLength, sequence } = acc || initialAcc;
      if (chunk.readUInt16BE(0) !== channel) {
        throw new TransportError("Invalid channel", "InvalidChannel");
      }
      if (chunk.readUInt8(2) !== Tag) {
        throw new TransportError("Invalid tag", "InvalidTag");
      }
      if (chunk.readUInt16BE(3) !== sequence) {
        throw new TransportError("Invalid sequence", "InvalidSequence");
      }
      if (!acc) {
        dataLength = chunk.readUInt16BE(5);
      }
      sequence++;
      const chunkData = chunk.slice(acc ? 5 : 7);
      data = Buffer.concat([data, chunkData]);
      if (data.length > dataLength) {
        data = data.slice(0, dataLength);
      }
      return {
        data,
        dataLength,
        sequence
      };
    },
    /**
     * Returns the response message that has been reduced from the HID USB frames
     *
     * @param acc The accumulator
     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the
     *   accumulator is incorrect (message length is not valid)
     */
    getReducedResult(acc) {
      if (acc && acc.dataLength === acc.data.length) {
        return acc.data;
      }
    }
  };
};
var hid_framing_default = createHIDframing;

// ../node_modules/@ledgerhq/devices/lib-es/index.js
var import_semver = __toESM(require_semver());
var DeviceModelId;
(function(DeviceModelId2) {
  DeviceModelId2["blue"] = "blue";
  DeviceModelId2["nanoS"] = "nanoS";
  DeviceModelId2["nanoSP"] = "nanoSP";
  DeviceModelId2["nanoX"] = "nanoX";
  DeviceModelId2["stax"] = "stax";
  DeviceModelId2["europa"] = "europa";
  DeviceModelId2["apex"] = "apex";
})(DeviceModelId || (DeviceModelId = {}));
var devices = {
  [DeviceModelId.blue]: {
    id: DeviceModelId.blue,
    productName: "Ledger Blue",
    productIdMM: 0,
    legacyUsbProductId: 0,
    usbOnly: true,
    memorySize: 480 * 1024,
    masks: [822083584, 822149120],
    getBlockSize: (_firwareVersion) => 4 * 1024
  },
  [DeviceModelId.nanoS]: {
    id: DeviceModelId.nanoS,
    productName: "Ledger Nano S",
    productIdMM: 16,
    legacyUsbProductId: 1,
    usbOnly: true,
    memorySize: 320 * 1024,
    masks: [823132160],
    getBlockSize: (firmwareVersion) => import_semver.default.lt(import_semver.default.coerce(firmwareVersion) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024
  },
  [DeviceModelId.nanoX]: {
    id: DeviceModelId.nanoX,
    productName: "Ledger Nano X",
    productIdMM: 64,
    legacyUsbProductId: 4,
    usbOnly: false,
    memorySize: 2 * 1024 * 1024,
    masks: [855638016],
    getBlockSize: (_firwareVersion) => 4 * 1024,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
      }
    ]
  },
  [DeviceModelId.nanoSP]: {
    id: DeviceModelId.nanoSP,
    productName: "Ledger Nano S Plus",
    productIdMM: 80,
    legacyUsbProductId: 5,
    usbOnly: true,
    memorySize: 1533 * 1024,
    masks: [856686592],
    getBlockSize: (_firmwareVersion) => 32
  },
  [DeviceModelId.apex]: {
    id: DeviceModelId.apex,
    productName: "Ledger Nano Gen5",
    productIdMM: 128,
    legacyUsbProductId: 8,
    usbOnly: false,
    memorySize: 1533 * 1024,
    masks: [859832320],
    getBlockSize: (_firmwareVersion) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-8004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-8004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-8004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572"
      }
    ]
  },
  [DeviceModelId.stax]: {
    id: DeviceModelId.stax,
    productName: "Ledger Stax",
    productIdMM: 96,
    legacyUsbProductId: 6,
    usbOnly: false,
    memorySize: 1533 * 1024,
    masks: [857735168],
    getBlockSize: (_firmwareVersion) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
      }
    ]
  },
  [DeviceModelId.europa]: {
    id: DeviceModelId.europa,
    productName: "Ledger Flex",
    productIdMM: 112,
    legacyUsbProductId: 7,
    usbOnly: false,
    memorySize: 1533 * 1024,
    masks: [858783744],
    getBlockSize: (_firmwareVersion) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-3004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-3004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-3004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572"
      }
    ]
  }
};
var productMap = {
  Blue: DeviceModelId.blue,
  "Nano S": DeviceModelId.nanoS,
  "Nano S Plus": DeviceModelId.nanoSP,
  "Nano X": DeviceModelId.nanoX,
  Stax: DeviceModelId.stax,
  Europa: DeviceModelId.europa
};
var devicesList = Object.values(devices);
var ledgerUSBVendorId = 11415;
var identifyUSBProductId = (usbProductId) => {
  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);
  if (legacy)
    return legacy;
  const mm = usbProductId >> 8;
  const deviceModel = devicesList.find((d) => d.productIdMM === mm);
  return deviceModel;
};
var bluetoothServices = [];
var serviceUuidToInfos = {};
for (const id in devices) {
  const deviceModel = devices[id];
  const { bluetoothSpec } = deviceModel;
  if (bluetoothSpec) {
    for (let i = 0; i < bluetoothSpec.length; i++) {
      const spec = bluetoothSpec[i];
      bluetoothServices.push(spec.serviceUuid);
      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = {
        deviceModel,
        ...spec
      };
    }
  }
}

// ../node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js
init_lib_es();
var ledgerDevices = [
  {
    vendorId: ledgerUSBVendorId
  }
];
var isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));
var getHID = () => {
  const { hid } = navigator;
  if (!hid)
    throw new TransportError("navigator.hid is not supported", "HIDNotSupported");
  return hid;
};
async function requestLedgerDevices() {
  const device = await getHID().requestDevice({
    filters: ledgerDevices
  });
  if (Array.isArray(device))
    return device;
  return [device];
}
async function getLedgerDevices() {
  const devices2 = await getHID().getDevices();
  return devices2.filter((d) => d.vendorId === ledgerUSBVendorId);
}
async function getFirstLedgerDevice() {
  const existingDevices = await getLedgerDevices();
  if (existingDevices.length > 0)
    return existingDevices[0];
  const devices2 = await requestLedgerDevices();
  return devices2[0];
}
var _TransportWebHID = class _TransportWebHID extends Transport {
  constructor(device) {
    super();
    __publicField(this, "device");
    __publicField(this, "deviceModel");
    __publicField(this, "channel", Math.floor(Math.random() * 65535));
    __publicField(this, "packetSize", 64);
    __publicField(this, "inputs", []);
    __publicField(this, "inputCallback");
    __publicField(this, "read", () => {
      if (this.inputs.length) {
        return Promise.resolve(this.inputs.shift());
      }
      return new Promise((success) => {
        this.inputCallback = success;
      });
    });
    __publicField(this, "onInputReport", (e) => {
      const buffer = Buffer.from(e.data.buffer);
      if (this.inputCallback) {
        this.inputCallback(buffer);
        this.inputCallback = null;
      } else {
        this.inputs.push(buffer);
      }
    });
    __publicField(this, "_disconnectEmitted", false);
    __publicField(this, "_emitDisconnect", (e) => {
      if (this._disconnectEmitted)
        return;
      this._disconnectEmitted = true;
      this.emit("disconnect", e);
    });
    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */
    __publicField(this, "exchange", async (apdu) => {
      const b = await this.exchangeAtomicImpl(async () => {
        const { channel, packetSize } = this;
        log("apdu", "=> " + apdu.toString("hex"));
        const framing = hid_framing_default(channel, packetSize);
        const blocks = framing.makeBlocks(apdu);
        for (let i = 0; i < blocks.length; i++) {
          await this.device.sendReport(0, blocks[i]);
        }
        let result;
        let acc;
        while (!(result = framing.getReducedResult(acc))) {
          try {
            const buffer = await this.read();
            acc = framing.reduceResponse(acc, buffer);
          } catch (e) {
            if (e instanceof TransportError && e.id === "InvalidChannel") {
              continue;
            }
            throw e;
          }
        }
        log("apdu", "<= " + result.toString("hex"));
        return result;
      }).catch((e) => {
        if (e && e.message && e.message.includes("write")) {
          this._emitDisconnect(e);
          throw new DisconnectedDeviceDuringOperation(e.message);
        }
        throw e;
      });
      return b;
    });
    this.device = device;
    this.deviceModel = typeof device.productId === "number" ? identifyUSBProductId(device.productId) : void 0;
    device.addEventListener("inputreport", this.onInputReport);
  }
  /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */
  static async request() {
    const [device] = await requestLedgerDevices();
    return _TransportWebHID.open(device);
  }
  /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */
  static async openConnected() {
    const devices2 = await getLedgerDevices();
    if (devices2.length === 0)
      return null;
    return _TransportWebHID.open(devices2[0]);
  }
  /**
   * Create a Ledger transport with a HIDDevice
   */
  static async open(device) {
    await device.open();
    const transport = new _TransportWebHID(device);
    const onDisconnect = (e) => {
      if (device === e.device) {
        getHID().removeEventListener("disconnect", onDisconnect);
        transport._emitDisconnect(new DisconnectedDevice());
      }
    };
    getHID().addEventListener("disconnect", onDisconnect);
    return transport;
  }
  /**
   * Release the transport device
   */
  async close() {
    await this.exchangeBusyPromise;
    this.device.removeEventListener("inputreport", this.onInputReport);
    await this.device.close();
  }
  setScrambleKey() {
  }
};
/**
 * Check if WebUSB transport is supported.
 */
__publicField(_TransportWebHID, "isSupported", isSupported);
/**
 * List the WebUSB devices that was previously authorized by the user.
 */
__publicField(_TransportWebHID, "list", getLedgerDevices);
/**
 * Actively listen to WebUSB devices and emit ONE device
 * that was either accepted before, if not it will trigger the native permission UI.
 *
 * Important: it must be called in the context of a UI click!
 */
__publicField(_TransportWebHID, "listen", (observer) => {
  let unsubscribed = false;
  getFirstLedgerDevice().then((device) => {
    if (!device) {
      observer.error(new TransportOpenUserCancelled("Access denied to use Ledger device"));
    } else if (!unsubscribed) {
      const deviceModel = typeof device.productId === "number" ? identifyUSBProductId(device.productId) : void 0;
      observer.next({
        type: "add",
        descriptor: device,
        deviceModel
      });
      observer.complete();
    }
  }, (error) => {
    observer.error(new TransportOpenUserCancelled(error.message));
  });
  function unsubscribe() {
    unsubscribed = true;
  }
  return {
    unsubscribe
  };
});
var TransportWebHID = _TransportWebHID;
export {
  TransportWebHID as default
};
//# sourceMappingURL=TransportWebHID-FG4VCTJ5.js.map
