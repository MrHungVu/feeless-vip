{
  "version": 3,
  "sources": ["../../../../node_modules/@ledgerhq/devices/src/hid-framing.ts", "../../../../node_modules/@ledgerhq/devices/src/index.ts", "../../../../node_modules/@ledgerhq/hw-transport-webhid/src/TransportWebHID.ts"],
  "sourcesContent": ["import { TransportError } from \"@ledgerhq/errors\";\n\n// Represents a response message from the device being reduced from HID USB frames/packets\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      // The current frame id/number\n      sequence: number;\n    }\n  | null\n  | undefined;\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    /**\n     * Frames/encodes an APDU message into HID USB packets/frames\n     *\n     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n     * @returns an array of HID USB frames ready to be sent\n     */\n    makeBlocks(apdu: Buffer): Buffer[] {\n      // Encodes the APDU length in 2 bytes before the APDU itself.\n      // The length is measured as the number of bytes.\n      // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n      // the minimum size of an APDU is 5 bytes.\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n\n      // Fills data with 0-padding\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n\n        // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    /**\n     * Reduces HID USB packets/frames to one response.\n     *\n     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n     * @param chunk Current chunk to reduce into accumulator\n     * @returns An accumulator value updated with the current chunk\n     */\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      // Gets the total length of the response from the 1st frame\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      // The total length on the 1st frame takes 2 more bytes\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      // Removes any 0 padding\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    /**\n     * Returns the response message that has been reduced from the HID USB frames\n     *\n     * @param acc The accumulator\n     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n     *   accumulator is incorrect (message length is not valid)\n     */\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n", "import semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nexport enum DeviceModelId {\n  /** Ledger Blue */\n  blue = \"blue\",\n  /** Ledger Nano S */\n  nanoS = \"nanoS\",\n  /** Ledger Nano S Plus */\n  nanoSP = \"nanoSP\",\n  /** Ledger Nano X */\n  nanoX = \"nanoX\",\n  /** Ledger Stax */\n  stax = \"stax\",\n  /** Ledger Flex (\"europa\" is the internal name) */\n  europa = \"europa\", // DO NOT CHANGE TO FLEX or handle all migration issues, things will break\n  /** Apex */\n  apex = \"apex\",\n}\n\nconst devices: { [key in DeviceModelId]: DeviceModel } = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024,\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1533 * 1024,\n    masks: [0x33100000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n  },\n  [DeviceModelId.apex]: {\n    id: DeviceModelId.apex,\n    productName: \"Ledger Nano Gen5\",\n    productIdMM: 0x80,\n    legacyUsbProductId: 0x0008,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33400000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-8004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-8004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-8004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-8004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.stax]: {\n    id: DeviceModelId.stax,\n    productName: \"Ledger Stax\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33200000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.europa]: {\n    id: DeviceModelId.europa,\n    productName: \"Ledger Flex\",\n    productIdMM: 0x70,\n    legacyUsbProductId: 0x0007,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33300000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  Stax: DeviceModelId.stax,\n  Europa: DeviceModelId.europa,\n};\n\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId: number): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(({ masks }) =>\n    masks.find(mask => (targetId & 0xffff0000) === mask),\n  );\n\n  return deviceModel;\n};\n\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = (usbProductId: number): DeviceModel | null | undefined => {\n  const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find(d => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (productName: string): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: Record<string, BluetoothInfos> = {};\n\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = {\n        deviceModel,\n        ...spec,\n      };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = (): string[] => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid: string): BluetoothInfos | undefined =>\n  serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport interface DeviceModel {\n  id: DeviceModelId;\n  productName: string;\n  productIdMM: number;\n  legacyUsbProductId: number;\n  usbOnly: boolean;\n  memorySize: number;\n  masks: number[];\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number;\n  bluetoothSpec?: {\n    serviceUuid: string;\n    writeUuid: string;\n    writeCmdUuid: string;\n    notifyUuid: string;\n  }[];\n}\n\n/**\n *\n */\nexport interface BluetoothInfos {\n  deviceModel: DeviceModel;\n  serviceUuid: string;\n  writeUuid: string;\n  writeCmdUuid: string;\n  notifyUuid: string;\n}\n", "import Transport from \"@ledgerhq/hw-transport\";\nimport type { Observer, DescriptorEvent, Subscription } from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices,\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  device: HIDDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel =\n      typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs: Buffer[] = [];\n  inputCallback: ((arg0: Buffer) => void) | null | undefined;\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift() as unknown as Buffer);\n    }\n\n    return new Promise(success => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = (e: HIDInputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (observer: Observer<DescriptorEvent<HIDDevice>>): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!device) {\n          observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n        } else if (!unsubscribed) {\n          const deviceModel =\n            typeof device.productId === \"number\"\n              ? identifyUSBProductId(device.productId)\n              : undefined;\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      error => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      },\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async (apdu: Buffer): Promise<Buffer> => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        try {\n          const buffer = await this.read();\n          acc = framing.reduceResponse(acc, buffer);\n        } catch (e) {\n          if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n            // this can happen if the device is connected\n            // on a different channel (like another app)\n            // in this case we just filter out the event\n            continue;\n          }\n\n          throw e;\n        }\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n    return b as Buffer;\n  };\n\n  setScrambleKey() {}\n}\n"],
  "mappings": "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",
  "names": ["DeviceModelId", "semver", "devices"]
}
