import {
  TronLinkAdapter
} from "./chunk-JFDTCSIU.js";
import {
  WalletNotSelectedError,
  isInBrowser
} from "./chunk-MXXBAQAJ.js";
import {
  require_react
} from "./chunk-SF63QKDS.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// ../node_modules/@tronweb3/tronwallet-adapter-react-hooks/lib/esm/useLocalStorage.js
var import_react = __toESM(require_react(), 1);
function useLocalStorage(key, defaultState) {
  const [state, setState] = (0, import_react.useState)(() => {
    try {
      const value = localStorage.getItem(key);
      if (value)
        return JSON.parse(value);
    } catch (error) {
      if (isInBrowser()) {
        console.error(error);
      }
    }
    return defaultState;
  });
  const isFirstRender = (0, import_react.useRef)(true);
  (0, import_react.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    try {
      if (state === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(state));
      }
    } catch (error) {
      if (isInBrowser()) {
        console.error(error);
      }
    }
  }, [state, key]);
  return [state, setState];
}

// ../node_modules/@tronweb3/tronwallet-adapter-react-hooks/lib/esm/useWallet.js
var import_react2 = __toESM(require_react(), 1);
function printError() {
  console.error(`
You are using WalletContext without provide the WalletContext.Provider.
Please wrap your sub-components with a WalletProvider and provide required values.
`);
}
var DEFAULT_CONTEXT = {
  autoConnect: false,
  connecting: false,
  connected: false,
  disconnecting: false,
  /* eslint-disable */
  select(_name) {
    printError();
  },
  connect() {
    printError();
    return Promise.reject();
  },
  disconnect() {
    printError();
    return Promise.reject();
  },
  signTransaction(_transaction) {
    printError();
    return Promise.reject();
  },
  signMessage(_message) {
    printError();
    return Promise.reject();
  }
  /* eslint-enable */
};
Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
  get() {
    printError();
    return [];
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
  get() {
    printError();
    return null;
  }
});
Object.defineProperty(DEFAULT_CONTEXT, "address", {
  get() {
    printError();
    return null;
  }
});
var WalletContext = (0, import_react2.createContext)(DEFAULT_CONTEXT);
function useWallet() {
  return (0, import_react2.useContext)(WalletContext);
}

// ../node_modules/@tronweb3/tronwallet-adapter-react-hooks/lib/esm/WalletProvider.js
var import_react3 = __toESM(require_react(), 1);
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var initialState = {
  wallet: null,
  address: null,
  connected: false,
  adapter: null
};
var WalletProvider = function({ children, adapters: adaptersPro = null, onError = (error) => console.error(error), onReadyStateChanged, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onAdapterChanged, localStorageKey = "tronAdapterName", autoConnect = true, disableAutoConnectOnLoad = false }) {
  const [name, setName] = useLocalStorage(localStorageKey, null);
  const [{ wallet, connected, address, adapter }, setState] = (0, import_react3.useState)(initialState);
  const [connecting, setConnecting] = (0, import_react3.useState)(false);
  const [disconnecting, setDisconnecting] = (0, import_react3.useState)(false);
  const isConnecting = (0, import_react3.useRef)(false);
  const isDisconnecting = (0, import_react3.useRef)(false);
  const adapters = (0, import_react3.useMemo)(() => {
    if (adaptersPro === null) {
      return [new TronLinkAdapter()];
    }
    return adaptersPro;
  }, [adaptersPro]);
  const [wallets, setWallets] = (0, import_react3.useState)(() => adapters.map((adapter2) => ({
    adapter: adapter2,
    state: adapter2.state
  })));
  (0, import_react3.useEffect)(function() {
    setWallets((prevWallets) => adapters.map((adapter2, index) => {
      const wallet2 = prevWallets[index];
      if (wallet2 && wallet2.adapter === adapter2 && wallet2.state === adapter2.state) {
        return wallet2;
      }
      return {
        adapter: adapter2,
        state: adapter2.state
      };
    }));
    function handleStateChange() {
      setWallets((prevWallets) => {
        const index = prevWallets.findIndex((wallet2) => wallet2.adapter === this);
        if (index === -1) {
          return prevWallets;
        }
        return prevWallets.map((wallet2, idx) => {
          if (idx === index) {
            return Object.assign(Object.assign({}, wallet2), { state: wallet2.adapter.state });
          }
          return wallet2;
        });
      });
    }
    adapters.forEach((adapter2) => adapter2.on("stateChanged", handleStateChange, adapter2));
    return () => adapters.forEach((adapter2) => adapter2.off("stateChanged", handleStateChange, adapter2));
  }, [adapters]);
  (0, import_react3.useEffect)(function() {
    const wallet2 = name && wallets.find((item) => item.adapter.name === name);
    if (wallet2) {
      setState({
        wallet: wallet2,
        adapter: wallet2.adapter,
        connected: wallet2.adapter.connected,
        address: wallet2.adapter.address
      });
    } else {
      setState(initialState);
    }
  }, [name, wallets]);
  const preAdapter = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(function() {
    if (adapter !== preAdapter.current) {
      onAdapterChanged === null || onAdapterChanged === void 0 ? void 0 : onAdapterChanged(adapter);
      preAdapter.current = adapter;
    }
  }, [adapter, onAdapterChanged]);
  const handleConnect = (0, import_react3.useCallback)(function(addr) {
    if (!adapter) {
      return setName(null);
    }
    setState((state) => Object.assign(Object.assign({}, state), { connected: adapter.connected, address: adapter.address }));
    onConnect === null || onConnect === void 0 ? void 0 : onConnect(addr);
  }, [adapter, setName, onConnect]);
  const handleError = (0, import_react3.useCallback)(function(error) {
    onError(error);
    return error;
  }, [onError]);
  const handleAccountChange = (0, import_react3.useCallback)(function(address2, preAddr) {
    setState((state) => Object.assign(Object.assign({}, state), { address: address2 }));
    onAccountsChanged === null || onAccountsChanged === void 0 ? void 0 : onAccountsChanged(address2, preAddr);
  }, [onAccountsChanged]);
  const handleDisconnect = (0, import_react3.useCallback)(function() {
    onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect();
  }, [onDisconnect]);
  const handleReadyStateChanged = (0, import_react3.useCallback)(function(readyState) {
    onReadyStateChanged === null || onReadyStateChanged === void 0 ? void 0 : onReadyStateChanged(readyState);
  }, [onReadyStateChanged]);
  const handleChainChanged = (0, import_react3.useCallback)(function(chainData) {
    onChainChanged === null || onChainChanged === void 0 ? void 0 : onChainChanged(chainData);
  }, [onChainChanged]);
  (0, import_react3.useEffect)(function() {
    if (adapter) {
      adapter.on("connect", handleConnect);
      adapter.on("error", handleError);
      adapter.on("accountsChanged", handleAccountChange);
      adapter.on("chainChanged", handleChainChanged);
      adapter.on("readyStateChanged", handleReadyStateChanged);
      adapter.on("disconnect", handleDisconnect);
      return () => {
        adapter.off("connect", handleConnect);
        adapter.off("error", handleError);
        adapter.off("accountsChanged", handleAccountChange);
        adapter.off("chainChanged", handleChainChanged);
        adapter.off("readyStateChanged", handleReadyStateChanged);
        adapter.off("disconnect", handleDisconnect);
      };
    }
  }, [
    adapter,
    handleConnect,
    handleError,
    handleAccountChange,
    handleChainChanged,
    handleReadyStateChanged,
    handleDisconnect
  ]);
  (0, import_react3.useEffect)(() => {
    return () => {
      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();
    };
  }, [adapter]);
  const hasManuallySetName = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(function() {
    const canAutoConnect = autoConnect && (!disableAutoConnectOnLoad || hasManuallySetName.current);
    if (isConnecting.current || !canAutoConnect || !adapter) {
      return;
    }
    (function connect2() {
      return __awaiter(this, void 0, void 0, function* () {
        isConnecting.current = true;
        setConnecting(true);
        try {
          yield adapter.connect();
        } catch (error) {
        } finally {
          setConnecting(false);
          isConnecting.current = false;
        }
      });
    })();
  }, [isConnecting, autoConnect, adapter, setName, disableAutoConnectOnLoad]);
  const select = (0, import_react3.useCallback)((name2) => {
    hasManuallySetName.current = true;
    setName(name2);
  }, [setName]);
  const connect = (0, import_react3.useCallback)(function() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isConnecting.current || isDisconnecting.current || connected) {
        return;
      }
      if (!adapter)
        throw handleError(new WalletNotSelectedError());
      isConnecting.current = true;
      setConnecting(true);
      try {
        yield adapter.connect();
      } catch (error) {
        setName(null);
        throw error;
      } finally {
        setConnecting(false);
        isConnecting.current = false;
      }
    });
  }, [isConnecting, isDisconnecting, adapter, connected, handleError, setName]);
  const disconnect = (0, import_react3.useCallback)(function() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isDisconnecting.current)
        return;
      if (!adapter)
        return setName(null);
      isDisconnecting.current = true;
      setDisconnecting(true);
      try {
        yield adapter.disconnect();
        setName(null);
      } catch (error) {
        setName(null);
        throw error;
      } finally {
        setDisconnecting(false);
        isDisconnecting.current = false;
      }
    });
  }, [adapter, isDisconnecting, setName]);
  const signTransaction = (0, import_react3.useCallback)(function(transaction, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!adapter)
        throw handleError(new WalletNotSelectedError());
      return yield adapter.signTransaction(transaction, privateKey);
    });
  }, [adapter, handleError]);
  const signMessage = (0, import_react3.useCallback)(function(message, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!adapter)
        throw handleError(new WalletNotSelectedError());
      return yield adapter.signMessage(message, privateKey);
    });
  }, [adapter, handleError]);
  return import_react3.default.createElement(WalletContext.Provider, { value: {
    disableAutoConnectOnLoad,
    autoConnect,
    wallets,
    wallet,
    address,
    connecting,
    connected,
    disconnecting,
    select,
    connect,
    disconnect,
    signTransaction,
    signMessage
  } }, children);
};

export {
  useLocalStorage,
  WalletContext,
  useWallet,
  WalletProvider
};
//# sourceMappingURL=chunk-BC6V7QIY.js.map
