import {
  ConnectorUtil,
  WalletUtil
} from "./chunk-YUBRYVSQ.js";
import {
  CaipNetworksUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  ProviderUtil
} from "./chunk-NEXHQUEX.js";
import {
  W3mFrameHelpers,
  W3mFrameProvider
} from "./chunk-5O7QEJOR.js";
import {
  B,
  EnsController,
  Kt,
  OnRampController,
  SIWXUtil,
  setColorTheme,
  setThemeVariables,
  vs
} from "./chunk-B3ZV4KHH.js";
import {
  AccountController,
  AlertController,
  ApiController,
  AssetUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  ModalController,
  NetworkUtil,
  OptionsController,
  ParseUtil,
  PublicStateController,
  RouterController,
  SendController,
  SnackController,
  StorageUtil,
  ThemeController,
  W3mFrameRpcConstants,
  getActiveCaipNetwork,
  getPreferredAccountType,
  getW3mThemeVariables
} from "./chunk-LI2VV255.js";
import {
  esm_exports,
  require_cjs,
  require_cjs2
} from "./chunk-5ITTDC3H.js";
import {
  require_events
} from "./chunk-P462YRXK.js";
import {
  toHex
} from "./chunk-CIFUO6GN.js";
import {
  esm_default
} from "./chunk-OAUNBI7H.js";
import {
  Adapter,
  AdapterState,
  ChainNetwork,
  WalletConnectionError,
  WalletDisconnectedError,
  WalletDisconnectionError,
  WalletNotFoundError,
  WalletReadyState,
  WalletSignMessageError,
  WalletSignTransactionError,
  WalletWindowClosedError
} from "./chunk-MXXBAQAJ.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// ../node_modules/@reown/appkit/dist/esm/src/auth-provider/W3MFrameProviderSingleton.js
var W3mFrameProviderSingleton = class _W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, enableLogger, onTimeout, abortController, getActiveCaipNetwork: getActiveCaipNetwork2, getCaipNetworks }) {
    var _a2;
    if (!_W3mFrameProviderSingleton.instance) {
      _W3mFrameProviderSingleton.instance = new W3mFrameProvider({
        projectId,
        chainId,
        enableLogger,
        onTimeout,
        abortController,
        getActiveCaipNetwork: getActiveCaipNetwork2,
        getCaipNetworks,
        enableCloudAuthAccount: Boolean((_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.emailCapture)
      });
    }
    return _W3mFrameProviderSingleton.instance;
  }
};

// ../node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string = value.startsWith("0x") ? value.slice(2) : value;
    const number = parseInt(string, 16);
    return number;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    var _a2, _b;
    const rpcUrls = ((_a2 = caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _a2.http) || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [(_b = caipNetwork.blockExplorers) == null ? void 0 : _b.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// ../node_modules/@reown/appkit-utils/dist/esm/src/bitcoin/BitcoinConstantsUtil.js
var BitcoinConstantsUtil = {
  ACCOUNT_INDEXES: {
    PAYMENT: 0,
    ORDINAL: 1
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// ../node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// ../node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// ../node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// ../node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// ../node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns) => namespacesToOverride.add(ns));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns] = chainId.split(":");
        if (ns) {
          namespacesToOverride.add(ns);
        }
      });
    }
    namespacesToOverride.forEach((ns) => {
      if (!result[ns]) {
        result[ns] = this.createDefaultNamespace(ns);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns, methods]) => {
        if (result[ns]) {
          result[ns].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns, chains]) => {
        if (result[ns]) {
          result[ns].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns, events]) => {
        if (result[ns]) {
          result[ns].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns, id] = chainId.split(":");
        if (!ns || !id || !result[ns]) {
          return;
        }
        if (!result[ns].rpcMap) {
          result[ns].rpcMap = {};
        }
        if (!processedNamespaces.has(ns)) {
          result[ns].rpcMap = {};
          processedNamespaces.add(ns);
        }
        result[ns].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    var _a2;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a2 = networkNameAddresses[0]) == null ? void 0 : _a2.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  },
  listenWcProvider({ universalProvider, namespace, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onDisplayUri }) {
    if (onConnect) {
      universalProvider.on("connect", () => {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, namespace);
        onConnect(accounts);
      });
    }
    if (onDisconnect) {
      universalProvider.on("disconnect", () => {
        onDisconnect();
      });
    }
    if (onAccountsChanged) {
      universalProvider.on("accountsChanged", (accounts) => {
        var _a2, _b, _c, _d, _e;
        try {
          const allAccounts = ((_c = (_b = (_a2 = universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c.accounts) || [];
          const defaultChain = (_e = (_d = universalProvider.rpcProviders) == null ? void 0 : _d[namespace]) == null ? void 0 : _e.getDefaultChain();
          const parsedAccounts = accounts.map((account) => {
            const caipAccount = allAccounts.find((acc) => acc.includes(`${namespace}:${defaultChain}:${account}`));
            if (!caipAccount) {
              return void 0;
            }
            const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(caipAccount);
            return {
              address: account,
              chainId,
              chainNamespace
            };
          }).filter((account) => account !== void 0);
          if (parsedAccounts.length > 0) {
            onAccountsChanged(parsedAccounts);
          }
        } catch (error) {
          console.warn("Failed to parse accounts for namespace on accountsChanged event", namespace, accounts, error);
        }
      });
    }
    if (onChainChanged) {
      universalProvider.on("chainChanged", (chainId) => {
        onChainChanged(chainId);
      });
    }
    if (onDisplayUri) {
      universalProvider.on("display_uri", (uri) => {
        onDisplayUri(uri);
      });
    }
  },
  getWalletConnectAccounts(universalProvider, namespace) {
    var _a2, _b, _c, _d;
    const accountsAdded = /* @__PURE__ */ new Set();
    const accounts = (_d = (_c = (_b = (_a2 = universalProvider == null ? void 0 : universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c.accounts) == null ? void 0 : _d.map((account) => ParseUtil.parseCaipAddress(account)).filter(({ address }) => {
      if (accountsAdded.has(address.toLowerCase())) {
        return false;
      }
      accountsAdded.add(address.toLowerCase());
      return true;
    });
    if (accounts && accounts.length > 0) {
      return accounts;
    }
    return [];
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/connections/ConnectionManager.js
var ConnectionManager = class {
  constructor(params) {
    this.namespace = params.namespace;
  }
  async syncConnections(params) {
    switch (this.namespace) {
      case ConstantsUtil.CHAIN.EVM:
        await this.syncEVMConnections(params);
        break;
      case ConstantsUtil.CHAIN.SOLANA:
        await this.syncSolanaConnections(params);
        break;
      case ConstantsUtil.CHAIN.BITCOIN:
        await this.syncBitcoinConnections(params);
        break;
      default:
        throw new Error(`Unsupported chain namespace: ${this.namespace}`);
    }
  }
  async syncEVMConnections({ connectors, caipNetworks, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        const caipNetwork = caipNetworks.find((n2) => {
          var _a2, _b;
          return n2.chainNamespace === this.namespace && n2.id.toString() === ((_b = (_a2 = accounts[0]) == null ? void 0 : _a2.chainId) == null ? void 0 : _b.toString());
        });
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const { accounts, chainId } = await ConnectorUtil.fetchProviderData(connector);
        if (accounts.length > 0 && chainId) {
          const caipNetwork = caipNetworks.find((n2) => n2.chainNamespace === this.namespace && n2.id.toString() === chainId.toString());
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((address) => ({ address })),
            caipNetwork
          });
          if (connector.provider && connector.id !== ConstantsUtil.CONNECTOR_ID.AUTH && connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            onListenProvider(connector.id, connector.provider);
          }
        }
      }
    }));
  }
  async syncSolanaConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const address = await connector.connect({
          chainId: caipNetwork == null ? void 0 : caipNetwork.id
        });
        if (address) {
          onConnection({
            connectorId: connector.id,
            accounts: [{ address }],
            caipNetwork
          });
          onListenProvider(connector.id, connector.provider);
        }
      }
    }));
  }
  async syncBitcoinConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      var _a2, _b, _c, _d, _e, _f;
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts2 = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts2.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts2.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
        return;
      }
      const address = await connector.connect();
      const addresses = await connector.getAccountAddresses();
      let accounts = addresses == null ? void 0 : addresses.map((a) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.BITCOIN, a.address, a.purpose || "payment", a.publicKey, a.path));
      if (accounts && accounts.length > 1) {
        accounts = [
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_a2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _a2.publicKey) ?? "",
            path: ((_b = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _b.path) ?? "",
            address: ((_c = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _c.address) ?? "",
            type: "payment"
          },
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_d = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _d.publicKey) ?? "",
            path: ((_e = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _e.path) ?? "",
            address: ((_f = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _f.address) ?? "",
            type: "ordinal"
          }
        ];
      }
      const chain = connector.chains.find((c) => c.id === (caipNetwork == null ? void 0 : caipNetwork.id)) || connector.chains[0];
      if (!chain) {
        throw new Error("The connector does not support any of the requested chains");
      }
      if (address) {
        onListenProvider(connector.id, connector.provider);
        onConnection({
          connectorId: connector.id,
          accounts: accounts.map((a) => ({ address: a.address, type: a.type })),
          caipNetwork
        });
      }
    }));
  }
  /**
   * Gets a connection based on provided parameters.
   * If connectorId is provided, returns connection for that specific connector.
   * Otherwise, returns the first available valid connection.
   *
   * @param params - Connection parameters
   * @param params.address - Optional address to filter by
   * @param params.connectorId - Optional connector ID to filter by
   * @param params.connections - List of available connections
   * @param params.connectors - List of available connectors
   * @returns Connection or null if none found
   */
  getConnection({ address, connectorId, connections, connectors }) {
    if (connectorId) {
      const connection = connections.find((c) => HelpersUtil.isLowerCaseMatch(c.connectorId, connectorId));
      if (!connection) {
        return null;
      }
      const connector = connectors.find((c) => HelpersUtil.isLowerCaseMatch(c.id, connection.connectorId));
      const account = address ? connection.accounts.find((a) => HelpersUtil.isLowerCaseMatch(a.address, address)) : connection.accounts[0];
      return { ...connection, account, connector };
    }
    const validConnection = connections.find((c) => c.accounts.length > 0 && connectors.some((conn) => HelpersUtil.isLowerCaseMatch(conn.id, c.connectorId)));
    if (validConnection) {
      const [account] = validConnection.accounts;
      const connector = connectors.find((c) => HelpersUtil.isLowerCaseMatch(c.id, validConnection.connectorId));
      return {
        ...validConnection,
        account,
        connector
      };
    }
    return null;
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://localhost:*",
    "http://127.0.0.1:*",
    "https://127.0.0.1:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// ../node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// ../node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var IGNORED_CONNECTOR_IDS_FOR_LISTENER = [
  ConstantsUtil.CONNECTOR_ID.AUTH,
  ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT
];
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.availableConnections = [];
    this.providerHandlers = {};
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getConnectorId = (namespace) => ConnectorController.getConnectorId(namespace);
    if (params) {
      this.construct(params);
    }
    if (params == null ? void 0 : params.namespace) {
      this.connectionManager = new ConnectionManager({
        namespace: params.namespace
      });
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the available connections.
   * @returns {Connection[]} An array of available connections
   */
  get connections() {
    return this.availableConnections;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Handles the auth connected event.
   * @param {W3mFrameTypes.Responses['FrameGetUserResponse']} user - The user response
   */
  onAuthConnected({ accounts, chainId }) {
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === (chainId == null ? void 0 : chainId.toString()));
    if (accounts && caipNetwork) {
      this.addConnection({
        connectorId: ConstantsUtil.CONNECTOR_ID.AUTH,
        accounts,
        caipNetwork
      });
    }
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    authProvider.onConnect(this.onAuthConnected.bind(this));
    authProvider.onSocialConnected(this.onAuthConnected.bind(this));
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  /**
   * Adds connections to the available connections list
   * @param {...Connection} connections - The connections to add
   */
  addConnection(...connections) {
    const connectionsAdded = /* @__PURE__ */ new Set();
    this.availableConnections = [...connections, ...this.availableConnections].filter((connection) => {
      if (connectionsAdded.has(connection.connectorId.toLowerCase())) {
        return false;
      }
      connectionsAdded.add(connection.connectorId.toLowerCase());
      return true;
    });
    this.emit("connections", this.availableConnections);
  }
  /**
   * Deletes a connection from the available connections list
   * @param {string} connectorId - The connector ID of the connection to delete
   */
  deleteConnection(connectorId) {
    this.availableConnections = this.availableConnections.filter((c) => !HelpersUtil.isLowerCaseMatch(c.connectorId, connectorId));
    this.emit("connections", this.availableConnections);
  }
  /**
   * Clears all connections from the available connections list
   * @param {boolean} emit - Whether to emit the connections event
   */
  clearConnections(emit = false) {
    this.availableConnections = [];
    if (emit) {
      this.emit("connections", this.availableConnections);
    }
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a2;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a2 = this.eventListeners.get(eventName)) == null ? void 0 : _a2.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = getPreferredAccountType(caipNetwork.chainNamespace);
      await authProvider.switchNetwork({ chainId: caipNetwork.caipNetworkId });
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c) => c instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  /**
   * Handles connect event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onConnect(accounts, connectorId) {
    if (accounts.length > 0) {
      const { address, chainId } = CoreHelperUtil.getAccount(accounts[0]);
      const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === (chainId == null ? void 0 : chainId.toString()));
      const connector = this.connectors.find((c) => c.id === connectorId);
      if (address) {
        this.emit("accountChanged", {
          address,
          chainId,
          connector
        });
        this.addConnection({
          connectorId,
          accounts: accounts.map((_account) => {
            const { address: address2 } = CoreHelperUtil.getAccount(_account);
            return { address: address2 };
          }),
          caipNetwork
        });
      }
    }
  }
  /**
   * Handles accounts changed event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onAccountsChanged(accounts, connectorId, disconnectIfNoAccounts = true) {
    var _a2, _b;
    if (accounts.length > 0) {
      const { address } = CoreHelperUtil.getAccount(accounts[0]);
      const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
        connectorId,
        connections: this.connections,
        connectors: this.connectors
      });
      if (address && HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
        this.emit("accountChanged", {
          address,
          chainId: (_b = connection == null ? void 0 : connection.caipNetwork) == null ? void 0 : _b.id,
          connector: connection == null ? void 0 : connection.connector
        });
      }
      this.addConnection({
        connectorId,
        accounts: accounts.map((_account) => {
          const { address: address2 } = CoreHelperUtil.getAccount(_account);
          return { address: address2 };
        }),
        caipNetwork: connection == null ? void 0 : connection.caipNetwork
      });
    } else if (disconnectIfNoAccounts) {
      this.onDisconnect(connectorId);
    }
  }
  /**
   * Handles disconnect event for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  onDisconnect(connectorId) {
    this.removeProviderListeners(connectorId);
    this.deleteConnection(connectorId);
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emitFirstAvailableConnection();
    }
    if (this.connections.length === 0) {
      this.emit("disconnect");
    }
  }
  /**
   * Handles chain changed event for a specific connector.
   * @param {string} chainId - The ID of the chain that changed
   * @param {string} connectorId - The ID of the connector
   */
  onChainChanged(chainId, connectorId) {
    var _a2;
    const formattedChainId = typeof chainId === "string" && chainId.startsWith("0x") ? EthersHelpersUtil.hexStringToNumber(chainId).toString() : chainId.toString();
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connectorId,
      connections: this.connections,
      connectors: this.connectors
    });
    const caipNetwork = this.getCaipNetworks().filter((n2) => n2.chainNamespace === this.namespace).find((n2) => n2.id.toString() === formattedChainId);
    if (connection) {
      this.addConnection({
        connectorId,
        accounts: connection.accounts,
        caipNetwork
      });
    }
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emit("switchNetwork", { chainId: formattedChainId });
    }
  }
  /**
   * Listens to provider events for a specific connector.
   * @param {string} connectorId - The ID of the connector
   * @param {Provider | CombinedProvider} provider - The provider to listen to
   */
  listenProviderEvents(connectorId, provider) {
    if (IGNORED_CONNECTOR_IDS_FOR_LISTENER.includes(connectorId)) {
      return;
    }
    const accountsChangedHandler = (accounts) => this.onAccountsChanged(accounts, connectorId);
    const chainChangedHandler = (chainId) => this.onChainChanged(chainId, connectorId);
    const disconnectHandler = () => this.onDisconnect(connectorId);
    if (!this.providerHandlers[connectorId]) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChangedHandler);
      this.providerHandlers[connectorId] = {
        provider,
        disconnect: disconnectHandler,
        accountsChanged: accountsChangedHandler,
        chainChanged: chainChangedHandler
      };
    }
  }
  /**
   * Removes provider listeners for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  removeProviderListeners(connectorId) {
    if (this.providerHandlers[connectorId]) {
      const { provider, disconnect, accountsChanged, chainChanged } = this.providerHandlers[connectorId];
      provider.removeListener("disconnect", disconnect);
      provider.removeListener("accountsChanged", accountsChanged);
      provider.removeListener("chainChanged", chainChanged);
      this.providerHandlers[connectorId] = null;
    }
  }
  /**
   * Emits the first available connection.
   */
  emitFirstAvailableConnection() {
    var _a2, _b;
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      const [account] = connection.accounts;
      this.emit("accountChanged", {
        address: account == null ? void 0 : account.address,
        chainId: (_b = connection.caipNetwork) == null ? void 0 : _b.id,
        connector: connection.connector
      });
    }
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  async setUniversalProvider(universalProvider) {
    if (!this.namespace) {
      throw new Error("UniversalAdapter:setUniversalProvider - namespace is required");
    }
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
    return Promise.resolve();
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
      this.emit("disconnect");
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
    return { connections: [] };
  }
  syncConnections() {
    return Promise.resolve();
  }
  async getAccounts({ namespace }) {
    var _a2, _b, _c, _d;
    const provider = this.provider;
    const addresses = ((_d = (_c = (_b = (_a2 = provider == null ? void 0 : provider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c.accounts) == null ? void 0 : _d.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self) => self.indexOf(address) === index)) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    var _a2, _b, _c, _d, _e;
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes((_a2 = params.caipNetwork) == null ? void 0 : _a2.chainNamespace);
    if (!isBalanceSupported || ((_b = params.caipNetwork) == null ? void 0 : _b.testnet)) {
      return {
        balance: "0.00",
        symbol: ((_c = params.caipNetwork) == null ? void 0 : _c.nativeCurrency.symbol) || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.id)) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b) => {
      var _a3, _b2;
      return b.chainId === `${(_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace}:${params.chainId}` && b.symbol === ((_b2 = params.caipNetwork) == null ? void 0 : _b2.nativeCurrency.symbol);
    });
    return {
      balance: (balance == null ? void 0 : balance.quantity.numeric) || "0.00",
      symbol: (balance == null ? void 0 : balance.symbol) || ((_e = params.caipNetwork) == null ? void 0 : _e.nativeCurrency.symbol) || ""
    };
  }
  async signMessage(params) {
    var _a2, _b, _c;
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.chainNamespace) === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, (_c = ChainController.state.activeCaipNetwork) == null ? void 0 : _c.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  emitFirstAvailableConnection() {
    return void 0;
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    var _a2, _b, _c, _d, _e, _f;
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await ((_a2 = connector.provider) == null ? void 0 : _a2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex(caipNetwork.id) }]
        }));
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_c = (_b = switchError == null ? void 0 : switchError.data) == null ? void 0 : _b.originalError) == null ? void 0 : _c.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await ((_f = connector.provider) == null ? void 0 : _f.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex(caipNetwork.id),
                  rpcUrls: [(_d = caipNetwork == null ? void 0 : caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _d.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [(_e = caipNetwork.blockExplorers) == null ? void 0 : _e.default.url]
                }
              ]
            }));
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c) => c.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding",
  "multiWallet",
  "emailCapture",
  "payWithExchange",
  "payments",
  "reownAuthentication"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s) => s !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  },
  emailCapture: {
    apiFeatureName: "email_capture",
    localFeatureName: "emailCapture",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => apiConfig.isEnabled && (apiConfig.config ?? []),
    processFallback: (_localValue) => false
  },
  multiWallet: {
    apiFeatureName: "multi_wallet",
    localFeatureName: "multiWallet",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.multiWallet
  },
  payWithExchange: {
    apiFeatureName: "fund_from_exchange",
    localFeatureName: "payWithExchange",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payWithExchange
  },
  payments: {
    apiFeatureName: "payments",
    localFeatureName: "payments",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payments
  },
  reownAuthentication: {
    apiFeatureName: "reown_authentication",
    localFeatureName: "reownAuthentication",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (typeof localValue === "undefined") {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownAuthentication;
      }
      return Boolean(localValue);
    }
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig == null ? void 0 : apiProjectConfig.find((f3) => f3.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if ((apiConfig == null ? void 0 : apiConfig.config) === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let shouldUseApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      shouldUseApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e);
    }
    const remoteFeaturesConfig = shouldUseApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, shouldUseApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (shouldUseApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        debugMessage: ErrorUtil.ALERT_WARNINGS.LOCAL_CONFIGURATION_IGNORED.debugMessage(warningMessage)
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      var _a2, _b, _c;
      if (chainNamespace) {
        const caipNetworkWithId = (_a2 = ChainController.getCaipNetworks(chainNamespace)) == null ? void 0 : _a2.find((c) => c.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = (_b = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _b.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return (_c = requestedCaipNetworks.filter((c) => c.chainNamespace === chainNamespace)) == null ? void 0 : _c[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      var _a2, _b;
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => getPreferredAccountType(namespace);
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => {
      var _a2, _b;
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      StorageUtil.setConnections(connections, chainNamespace);
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.getConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).connections;
    };
    this.getRecentConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).recentConnections;
    };
    this.switchConnection = async (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      await ConnectionController.switchConnection(params);
    };
    this.deleteConnection = (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      StorageUtil.deleteAddressFromConnection(params);
      ConnectionController.syncStorageConnections();
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderUtil.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getAddress = (chainNamespace) => {
      var _a2, _b;
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters == null ? void 0 : adapters.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces == null ? void 0 : adapterNamespaces.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks == null ? void 0 : caipNetworks.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    var _a2, _b, _c, _d, _e;
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    if (OptionsController.state.enableReconnect) {
      await this.syncExistingConnection();
      await this.syncAdapterConnections();
    } else {
      await this.unSyncExistingConnection();
    }
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (((_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.email) || Array.isArray((_b = OptionsController.state.remoteFeatures) == null ? void 0 : _b.socials) && ((_c = OptionsController.state.remoteFeatures) == null ? void 0 : _c.socials.length) > 0) {
      await this.checkAllowedOrigins();
    }
    if (((_d = OptionsController.state.features) == null ? void 0 : _d.reownAuthentication) || ((_e = OptionsController.state.remoteFeatures) == null ? void 0 : _e.reownAuthentication)) {
      const { ReownAuthentication } = await import("./features-EAF3XNWG.js");
      const currentSIWX = OptionsController.state.siwx;
      if (!(currentSIWX instanceof ReownAuthentication)) {
        if (currentSIWX) {
          console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden.");
        }
        OptionsController.setSIWX(new ReownAuthentication());
      }
    }
  }
  async checkAllowedOrigins() {
    try {
      const allowedOrigins = await ApiController.fetchAllowedOrigins();
      if (!allowedOrigins || !CoreHelperUtil.isClient()) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.ORIGIN_NOT_ALLOWED, "error");
      }
    } catch (error) {
      if (!(error instanceof Error)) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      switch (error.message) {
        case "RATE_LIMITED":
          AlertController.open(ErrorUtil.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const originalError = error.cause instanceof Error ? error.cause : error;
          AlertController.open({
            displayMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.displayMessage,
            debugMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.debugMessage(originalError.message)
          }, "error");
          break;
        }
        default:
          AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      }
    }
  }
  sendInitializeEvent(options) {
    var _a2;
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n2) => n2.id),
        siweConfig: {
          options: ((_a2 = options.siweConfig) == null ? void 0 : _a2.options) || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.initialize(options.adapters ?? []);
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    var _a2;
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableReconnect(options.enableReconnect !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = (_a2 = options.adapters) == null ? void 0 : _a2.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    var _a2, _b, _c, _d;
    if (CoreHelperUtil.isClient()) {
      return {
        name: ((_b = (_a2 = document.getElementsByTagName("title")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.textContent) || "",
        description: ((_c = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _c.content) || "",
        url: window.location.origin,
        icons: [((_d = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _d.href) || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n2) => {
      var _a2;
      return n2.id === ((_a2 = options.defaultNetwork) == null ? void 0 : _a2.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  async disconnectNamespace(namespace, id) {
    var _a2, _b;
    try {
      this.setLoading(true, namespace);
      let disconnectResult = {
        connections: []
      };
      const adapter = this.getAdapter(namespace);
      const caipAddress = (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
      if ((caipAddress || !OptionsController.state.enableReconnect) && (adapter == null ? void 0 : adapter.disconnect)) {
        disconnectResult = await adapter.disconnect({ id });
      }
      this.setLoading(false, namespace);
      return disconnectResult;
    } catch (error) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chains: ${error.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a2;
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = (_a2 = this.getCaipNetwork(activeChain)) == null ? void 0 : _a2.id;
        const connections = ConnectionController.getConnections(activeChain);
        const isMultiWallet = this.remoteFeatures.multiWallet;
        const hasConnections = connections.length > 0;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        const shouldClose = !hasConnections || !isMultiWallet;
        if (shouldClose) {
          this.close();
        }
        this.setClientId((result == null ? void 0 : result.clientId) || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        await this.syncWalletConnectAccount();
        await SIWXUtil.initializeIfEnabled();
      },
      connectExternal: async ({ id, address, info, type, provider, chain, caipNetwork, socialUri }) => {
        var _a2, _b, _c, _d, _e, _f;
        const activeChain = ChainController.state.activeChain;
        const namespace = chain || activeChain;
        const adapter = this.getAdapter(namespace);
        if (chain && chain !== activeChain && !caipNetwork) {
          const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!namespace) {
          throw new Error("connectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("connectExternal: adapter not found");
        }
        const fallbackCaipNetwork = this.getCaipNetwork(namespace);
        const res = await adapter.connect({
          id,
          address,
          info,
          type,
          provider,
          socialUri,
          chainId: (caipNetwork == null ? void 0 : caipNetwork.id) || (fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.id),
          rpcUrl: ((_c = (_b = (_a2 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a2.default) == null ? void 0 : _b.http) == null ? void 0 : _c[0]) || ((_f = (_e = (_d = fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.rpcUrls) == null ? void 0 : _d.default) == null ? void 0 : _e.http) == null ? void 0 : _f[0])
        });
        if (!res) {
          return void 0;
        }
        StorageUtil.addConnectedNamespace(namespace);
        this.syncProvider({ ...res, chainNamespace: namespace });
        this.setStatus("connected", namespace);
        this.syncConnectedWalletInfo(namespace);
        StorageUtil.removeDisconnectedConnectorId(id, namespace);
        return { address: res.address };
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("reconnectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("reconnectExternal: adapter not found");
        }
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id, info, type, provider, chainId: (_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id }));
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnect: async (params) => {
        var _a2;
        const { id: connectorIdParam, chainNamespace, initialDisconnect } = params || {};
        const namespace = chainNamespace || ChainController.state.activeChain;
        const namespaceConnectorId = ConnectorController.getConnectorId(namespace);
        const isAuth = connectorIdParam === ConstantsUtil.CONNECTOR_ID.AUTH || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isWalletConnect = connectorIdParam === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        try {
          const namespaces = Array.from(ChainController.state.chains.keys());
          let namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
          if (isWalletConnect || isAuth) {
            namespacesToDisconnect = namespaces;
          }
          const disconnectPromises = namespacesToDisconnect.map(async (ns) => {
            const connectorIdToDisconnect = ConnectorController.getConnectorId(ns);
            const disconnectData = await this.disconnectNamespace(ns, connectorIdParam || connectorIdToDisconnect);
            if (disconnectData) {
              if (isAuth) {
                StorageUtil.deleteConnectedSocialProvider();
              }
              disconnectData.connections.forEach((connection) => {
                StorageUtil.addDisconnectedConnectorId(connection.connectorId, ns);
              });
            }
            if (initialDisconnect) {
              this.onDisconnectNamespace({ chainNamespace: ns, closeModal: false });
            }
          });
          const disconnectResults = await Promise.allSettled(disconnectPromises);
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          if ((_a2 = SIWXUtil.getSIWX()) == null ? void 0 : _a2.signOutOnDisconnect) {
            await SIWXUtil.clearSessions();
          }
          ConnectorController.setFilterByNamespace(void 0);
          ConnectionController.syncStorageConnections();
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f3) => f3.reason.message).join(", "));
          }
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error) {
          throw new Error(`Failed to disconnect chains: ${error.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => {
          var _a2;
          return Boolean((_a2 = window.ethereum) == null ? void 0 : _a2[String(id)]);
        });
      },
      signMessage: async (message) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!namespace) {
          throw new Error("signMessage: namespace not found");
        }
        if (!adapter) {
          throw new Error("signMessage: adapter not found");
        }
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(namespace)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (!namespace) {
          throw new Error("sendTransaction: namespace not found");
        }
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("sendTransaction: adapter not found");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          }));
          return (result == null ? void 0 : result.hash) || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        const namespace = args.chainNamespace;
        if (namespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("estimateGas: adapter is required but got undefined");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("estimateGas: caipNetwork is required but got undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({ ...args, provider, caipNetwork }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("getEnsAvatar: namespace is required but got undefined");
        }
        await this.syncIdentity({
          address: AccountController.state.address,
          chainId: Number((_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id),
          chainNamespace: namespace
        });
        return AccountController.state.profileImage || false;
      },
      getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
      writeContract: async (args) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("writeContract: namespace is required but got undefined");
        }
        if (!adapter) {
          throw new Error("writeContract: adapter is required but got undefined");
        }
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(namespace);
        if (!caipNetwork || !caipAddress) {
          throw new Error("writeContract: caipNetwork or caipAddress is required but got undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result == null ? void 0 : result.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("parseUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("formatUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("getCapabilities: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("grantPermissions: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("revokePermissions: adapter is required but got undefined");
        }
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("walletGetAssets: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.walletGetAssets(params)) ?? {};
      },
      updateBalance: (namespace) => {
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !AccountController.state.address) {
          return;
        }
        this.updateNativeBalance(AccountController.state.address, caipNetwork == null ? void 0 : caipNetwork.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    var _a2, _b, _c, _d, _e;
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: ((_e = (_d = (_c = this.universalProvider) == null ? void 0 : _c.session) == null ? void 0 : _d.peer) == null ? void 0 : _e.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a2;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b) => b.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
          networks: this.getCaipNetworks()
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    var _a2;
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await ((_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnectors(this.options, this));
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (OptionsController.state.enableReconnect === false) {
      this.setStatus("disconnected", chainNamespace);
    } else if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a2, _b;
      const caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainId.toString() || n2.caipNetworkId.toString() === chainId.toString());
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", () => {
      const isMultiWallet = this.remoteFeatures.multiWallet;
      const allConnections = Array.from(ConnectionController.state.connections.values()).flat();
      this.onDisconnectNamespace({
        chainNamespace,
        closeModal: !isMultiWallet || allConnections.length === 0
      });
    });
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id)) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId, connector }) => {
      var _a2, _b;
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (connector == null ? void 0 : connector.provider) {
        this.syncProvider({
          id: connector.id,
          type: connector.type,
          provider: connector.provider,
          chainNamespace
        });
        this.syncConnectedWalletInfo(chainNamespace);
      }
      if (isActiveChain && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (isActiveChain && ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id)) {
        this.syncAccount({
          address,
          chainId: (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.id,
          chainNamespace
        });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
      StorageUtil.addConnectedNamespace(chainNamespace);
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    var _a2, _b, _c;
    await this.getUniversalProvider();
    if (this.universalProvider) {
      await ((_c = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setUniversalProvider) == null ? void 0 : _c.call(_b, this.universalProvider));
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async unSyncExistingConnection() {
    try {
      await Promise.allSettled(this.chainNamespaces.map((namespace) => ConnectionController.disconnect({ namespace, initialDisconnect: true })));
    } catch (error) {
      console.error("Error disconnecting existing connections:", error);
    }
  }
  async reconnectWalletConnect() {
    var _a2, _b, _c, _d;
    await this.syncWalletConnectAccount();
    const address = this.getAddress();
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      address,
      properties: {
        method: CoreHelperUtil.isMobile() ? "mobile" : "qrcode",
        name: ((_d = (_c = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.peer) == null ? void 0 : _c.metadata) == null ? void 0 : _d.name) || "Unknown",
        reconnect: true
      }
    });
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.reconnectWalletConnect();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  onDisconnectNamespace(options) {
    const { chainNamespace, closeModal } = options || {};
    ChainController.resetAccount(chainNamespace);
    ChainController.resetNetwork(chainNamespace);
    StorageUtil.removeConnectedNamespace(chainNamespace);
    const namespaces = Array.from(ChainController.state.chains.keys());
    const namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
    namespacesToDisconnect.forEach((ns) => StorageUtil.addDisconnectedConnectorId(ConnectorController.getConnectorId(ns) || "", ns));
    ConnectorController.removeConnectorId(chainNamespace);
    ProviderUtil.resetChain(chainNamespace);
    this.setUser(void 0, chainNamespace);
    this.setStatus("disconnected", chainNamespace);
    this.setConnectedWalletInfo(void 0, chainNamespace);
    if (closeModal !== false) {
      ModalController.close();
    }
  }
  async syncAdapterConnections() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => {
      var _a2;
      const caipAddress = this.getCaipAddress(namespace);
      const caipNetwork = this.getCaipNetwork(namespace);
      return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnections({
        connectToFirstConnector: !caipAddress,
        caipNetwork,
        getConnectorStorageInfo(connectorId) {
          const storageConnectionsByNamespace = StorageUtil.getConnections();
          const storageConnections = storageConnectionsByNamespace[namespace] ?? [];
          return {
            hasDisconnected: StorageUtil.isConnectorDisconnected(connectorId, namespace),
            hasConnected: storageConnections.some((c) => HelpersUtil.isLowerCaseMatch(c.connectorId, connectorId))
          };
        }
      });
    }));
  }
  async syncAdapterConnection(namespace) {
    var _a2, _b, _c, _d;
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c) => c.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!(caipNetwork == null ? void 0 : caipNetwork.id)) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await (adapter == null ? void 0 : adapter.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: (_c = (_b = (_a2 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a2.default) == null ? void 0 : _b.http) == null ? void 0 : _c[0]
      }));
      if (connection) {
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          address: connection.address,
          properties: {
            method: "browser",
            name: ((_d = connector.info) == null ? void 0 : _d.name) || connector.name || "Unknown",
            reconnect: true
          }
        });
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.onDisconnectNamespace({ chainNamespace: namespace, closeModal: false });
    }
  }
  async syncWalletConnectAccount() {
    var _a2, _b;
    const sessionNamespaces = Object.keys(((_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces) || {});
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      var _a3, _b2, _c, _d, _e;
      const adapter = this.getAdapter(chainNamespace);
      if (!adapter) {
        return;
      }
      const namespaceAccounts = ((_d = (_c = (_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces) == null ? void 0 : _c[chainNamespace]) == null ? void 0 : _d.accounts) || [];
      const activeChainId = (_e = ChainController.state.activeCaipNetwork) == null ? void 0 : _e.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === (activeChainId == null ? void 0 : activeChainId.toString());
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (sessionNamespaces.includes(chainNamespace)) {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAccount(params) {
    var _a2, _b;
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainId) === chainIdToUse.toString();
        });
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainNamespace) === chainNamespace;
        });
        caipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n2) => n2.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n2 && n2.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if ((network == null ? void 0 : network.chainNamespace) === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, AccountController.state.address)) {
        this.syncAccountInfo(address, network == null ? void 0 : network.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network == null ? void 0 : network.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain == null ? void 0 : networkOfChain.id, chainNamespace });
      }
      this.syncIdentity({
        address,
        chainId,
        chainNamespace
      });
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || (caipAddress == null ? void 0 : caipAddress.split(":")[1]);
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a2;
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connectors = this.getConnectors();
        const connector = connectors.find((c) => {
          var _a3, _b;
          const isConnectorId = c.id === connectorId;
          const isRdns = ((_a3 = c.info) == null ? void 0 : _a3.rdns) === connectorId;
          const hasMultiChainConnector = (_b = c.connectors) == null ? void 0 : _b.some((_c) => {
            var _a4;
            return _c.id === connectorId || ((_a4 = _c.info) == null ? void 0 : _a4.rdns) === connectorId;
          });
          return isConnectorId || isRdns || Boolean(hasMultiChainConnector);
        });
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a2 = provider.session.peer.metadata.icons) == null ? void 0 : _a2[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE_SDK || connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c) => c.id === connectorId);
        const name = (connector == null ? void 0 : connector.name) || "Coinbase Wallet";
        const icon = (connector == null ? void 0 : connector.imageUrl) || this.getConnectorImage(connector);
        const info = connector == null ? void 0 : connector.info;
        this.setConnectedWalletInfo({
          ...info,
          name,
          icon
        }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n2) => {
      var _a2;
      return n2.id.toString() === ((_a2 = params.chainId) == null ? void 0 : _a2.toString());
    });
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      metadata: {
        name: ((_b = this.options) == null ? void 0 : _b.metadata) ? (_c = this.options) == null ? void 0 : _c.metadata.name : "",
        description: ((_d = this.options) == null ? void 0 : _d.metadata) ? (_e = this.options) == null ? void 0 : _e.metadata.description : "",
        url: ((_f = this.options) == null ? void 0 : _f.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.url : "",
        icons: ((_h = this.options) == null ? void 0 : _h.metadata) ? (_i = this.options) == null ? void 0 : _i.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean((_j = this.options) == null ? void 0 : _j.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await B.init(universalProviderOptions);
    if (OptionsController.state.enableReconnect === false && this.universalProvider.session) {
      await this.universalProvider.disconnect();
    }
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.chainNamespaces.forEach((namespace) => {
        WcHelpersUtil.listenWcProvider({
          universalProvider: this.universalProvider,
          namespace,
          onDisplayUri: (uri) => {
            ConnectionController.setUri(uri);
          },
          onConnect: (accounts) => {
            const { address } = CoreHelperUtil.getAccount(accounts[0]);
            ConnectionController.finalizeWcConnection(address);
          },
          onDisconnect: () => {
            if (ChainController.state.noAdapters) {
              this.resetAccount(namespace);
            }
            ConnectionController.resetWcConnection();
          },
          onChainChanged: (chainId) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const caipNetwork = this.getCaipNetworks().find((n2) => n2.id.toString() === chainId.toString() || n2.caipNetworkId.toString() === chainId.toString());
              const currentCaipNetwork = this.getCaipNetwork();
              if (!caipNetwork) {
                this.setUnsupportedNetwork(chainId);
                return;
              }
              if ((currentCaipNetwork == null ? void 0 : currentCaipNetwork.id.toString()) !== (caipNetwork == null ? void 0 : caipNetwork.id.toString()) && (currentCaipNetwork == null ? void 0 : currentCaipNetwork.chainNamespace) === (caipNetwork == null ? void 0 : caipNetwork.chainNamespace)) {
                this.setCaipNetwork(caipNetwork);
              }
            }
          },
          onAccountsChanged: (accounts) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const account = accounts == null ? void 0 : accounts[0];
              if (account) {
                this.syncAccount({
                  address: account.address,
                  chainId: account.chainId,
                  chainNamespace: account.chainNamespace
                });
              }
            }
          }
        });
      });
    }
  }
  createUniversalProvider() {
    var _a2;
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && ((_a2 = this.options) == null ? void 0 : _a2.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    var _a2;
    if (!namespace) {
      return void 0;
    }
    return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace];
  }
  createAdapter(blueprint) {
    var _a2;
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      networks: this.getCaipNetworks()
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options == null ? void 0 : options.uri) {
      ConnectionController.setUri(options.uri);
    }
    if (options == null ? void 0 : options.arguments) {
      switch (options == null ? void 0 : options.view) {
        case "Swap":
          return ModalController.open({ ...options, data: { swap: options.arguments } });
        default:
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect({ namespace: chainNamespace });
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a2;
    return (_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id;
  }
  async switchNetwork(appKitNetwork) {
    const network = this.getCaipNetworks().find((n2) => n2.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  subscribeConnections(callback) {
    if (!this.remoteFeatures.multiWallet) {
      AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
      return () => void 0;
    }
    return ConnectionController.subscribe(callback);
  }
  getWalletInfo(namespace) {
    var _a2, _b;
    if (namespace) {
      return (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.connectedWalletInfo;
    }
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(_namespace) {
    const namespace = _namespace || ChainController.state.activeChain;
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    const activeConnectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const connections = ConnectionController.getConnections(namespace);
    if (!namespace) {
      throw new Error("AppKit:getAccount - namespace is required");
    }
    const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address, type, publicKey }) => CoreHelperUtil.createAccount(namespace, address, type || "eoa", publicKey)));
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState.user ? {
          ...accountState.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState.socialProvider || "email",
        accountType: getPreferredAccountType(namespace),
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback, namespace) {
    if (namespace) {
      return AccountController.subscribeKey("connectedWalletInfo", callback, namespace);
    }
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  getRemoteFeatures() {
    return OptionsController.state.remoteFeatures;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  subscribeRemoteFeatures(callback) {
    return OptionsController.subscribeKey("remoteFeatures", callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n2) => n2.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n2) => n2.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// ../node_modules/@reown/appkit/dist/esm/src/client/appkit.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Private ------------------------------------------------------------------
  async onAuthProviderConnected(user) {
    if (user.message && user.signature && user.siwxMessage) {
      await SIWXUtil.addEmbeddedWalletSession({
        chainId: user.siwxMessage.chainId,
        accountAddress: user.address,
        notBefore: user.siwxMessage.notBefore,
        statement: user.siwxMessage.statement,
        resources: user.siwxMessage.resources,
        requestId: user.siwxMessage.requestId,
        issuedAt: user.siwxMessage.issuedAt,
        domain: user.siwxMessage.domain,
        uri: user.siwxMessage.uri,
        version: user.siwxMessage.version,
        nonce: user.siwxMessage.nonce
      }, user.message, user.signature);
    }
    const namespace = ChainController.state.activeChain;
    if (!namespace) {
      throw new Error("AppKit:onAuthProviderConnected - namespace is required");
    }
    const caipAddress = namespace === ConstantsUtil.CHAIN.EVM ? `eip155:${user.chainId}:${user.address}` : `${user.chainId}:${user.address}`;
    const defaultAccountType = OptionsController.state.defaultAccountTypes[namespace];
    const currentAccountType = getPreferredAccountType(namespace);
    const preferredAccountType = user.preferredAccountType || currentAccountType || defaultAccountType;
    this.setCaipAddress(caipAddress, namespace);
    const { signature, siwxMessage, message, ...userWithOutSiwxData } = user;
    this.setUser({ ...AccountController.state.user || {}, ...userWithOutSiwxData }, namespace);
    this.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), namespace);
    this.setPreferredAccountType(preferredAccountType, namespace);
    this.setLoading(false, namespace);
  }
  setupAuthConnectorListeners(provider) {
    provider.onRpcRequest((request) => {
      if (W3mFrameHelpers.checkIfRequestExists(request)) {
        if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
          this.handleUnsafeRPCRequest();
        }
      } else {
        this.open();
        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
          method: request.method
        });
        setTimeout(() => {
          this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
        }, 300);
        provider.rejectRpcRequests();
      }
    });
    provider.onRpcError(() => {
      const isModalOpen = this.isOpen();
      if (isModalOpen) {
        if (this.isTransactionStackEmpty()) {
          this.close();
        } else {
          this.popTransactionStack("error");
        }
      }
    });
    provider.onRpcSuccess((_, request) => {
      const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
      const address = AccountController.state.address;
      const caipNetwork = ChainController.state.activeCaipNetwork;
      if (isSafeRequest) {
        return;
      }
      if (address && (caipNetwork == null ? void 0 : caipNetwork.id)) {
        this.updateNativeBalance(address, caipNetwork.id, caipNetwork.chainNamespace);
      }
      if (this.isTransactionStackEmpty()) {
        this.close();
      } else {
        this.popTransactionStack("success");
      }
    });
    provider.onNotConnected(() => {
      const namespace = ChainController.state.activeChain;
      if (!namespace) {
        throw new Error("AppKit:onNotConnected - namespace is required");
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      const isConnectedWithAuth = connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
      if (isConnectedWithAuth) {
        this.setCaipAddress(void 0, namespace);
        this.setLoading(false, namespace);
      }
    });
    provider.onConnect(this.onAuthProviderConnected.bind(this));
    provider.onSocialConnected(this.onAuthProviderConnected.bind(this));
    provider.onSetPreferredAccount(({ address, type }) => {
      const namespace = ChainController.state.activeChain;
      if (!namespace) {
        throw new Error("AppKit:onSetPreferredAccount - namespace is required");
      }
      if (!address) {
        return;
      }
      this.setPreferredAccountType(type, namespace);
    });
  }
  async syncAuthConnectorTheme(provider) {
    if (!provider) {
      return;
    }
    const theme = ThemeController.getSnapshot();
    const options = OptionsController.getSnapshot();
    await Promise.all([
      provider.syncDappData({
        metadata: options.metadata,
        sdkVersion: options.sdkVersion,
        projectId: options.projectId,
        sdkType: options.sdkType
      }),
      provider.syncTheme({
        themeMode: theme.themeMode,
        themeVariables: theme.themeVariables,
        w3mThemeVariables: getW3mThemeVariables(theme.themeVariables, theme.themeMode)
      })
    ]);
  }
  async syncAuthConnector(provider, chainNamespace) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const isAuthSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    const shouldSync = chainNamespace === ChainController.state.activeChain;
    if (!isAuthSupported) {
      return;
    }
    this.setLoading(true, chainNamespace);
    const isLoginEmailUsed = provider.getLoginEmailUsed();
    this.setLoading(isLoginEmailUsed, chainNamespace);
    if (isLoginEmailUsed) {
      this.setStatus("connecting", chainNamespace);
    }
    const email = provider.getEmail();
    const username = provider.getUsername();
    this.setUser({ ...((_a2 = AccountController.state) == null ? void 0 : _a2.user) || {}, username, email }, chainNamespace);
    this.setupAuthConnectorListeners(provider);
    const { isConnected } = await provider.isConnected();
    await this.syncAuthConnectorTheme(provider);
    if (chainNamespace && isAuthSupported && shouldSync) {
      const enabledNetworks = await provider.getSmartAccountEnabledNetworks();
      ChainController.setSmartAccountEnabledNetworks((enabledNetworks == null ? void 0 : enabledNetworks.smartAccountEnabledNetworks) || [], chainNamespace);
      if (isConnected && ((_b = this.connectionControllerClient) == null ? void 0 : _b.connectExternal)) {
        await ((_d = this.connectionControllerClient) == null ? void 0 : _d.connectExternal({
          id: ConstantsUtil.CONNECTOR_ID.AUTH,
          info: { name: ConstantsUtil.CONNECTOR_ID.AUTH },
          type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
          provider,
          chainId: (_c = ChainController.state.activeCaipNetwork) == null ? void 0 : _c.id,
          chain: chainNamespace
        }));
        this.setStatus("connected", chainNamespace);
        const socialProvider = StorageUtil.getConnectedSocialProvider();
        if (socialProvider) {
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_SUCCESS",
            address: AccountController.state.address,
            properties: {
              provider: socialProvider,
              reconnect: true
            }
          });
        } else {
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            address: AccountController.state.address,
            properties: {
              method: "email",
              name: ((_h = (_g = (_f = (_e = this.universalProvider) == null ? void 0 : _e.session) == null ? void 0 : _f.peer) == null ? void 0 : _g.metadata) == null ? void 0 : _h.name) || "Unknown",
              reconnect: true
            }
          });
        }
      } else if (ConnectorController.getConnectorId(chainNamespace) === ConstantsUtil.CONNECTOR_ID.AUTH) {
        this.setStatus("disconnected", chainNamespace);
        StorageUtil.removeConnectedNamespace(chainNamespace);
      }
    }
    this.setLoading(false, chainNamespace);
  }
  async checkExistingTelegramSocialConnection(chainNamespace) {
    var _a2;
    try {
      if (!CoreHelperUtil.isTelegram()) {
        return;
      }
      const socialProviderToConnect = StorageUtil.getTelegramSocialProvider();
      if (!socialProviderToConnect) {
        return;
      }
      if (!CoreHelperUtil.isClient()) {
        return;
      }
      const url = new URL(window.location.href);
      const resultUri = url.searchParams.get("result_uri");
      if (!resultUri) {
        return;
      }
      AccountController.setSocialProvider(socialProviderToConnect, chainNamespace);
      await ((_a2 = this.authProvider) == null ? void 0 : _a2.init());
      const authConnector = ConnectorController.getAuthConnector();
      if (socialProviderToConnect && authConnector) {
        this.setLoading(true, chainNamespace);
        await ConnectionController.connectExternal({
          id: authConnector.id,
          type: authConnector.type,
          socialUri: resultUri
        }, authConnector.chain);
        StorageUtil.setConnectedSocialProvider(socialProviderToConnect);
        StorageUtil.removeTelegramSocialProvider();
        EventsController.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: socialProviderToConnect }
        });
      }
    } catch (error) {
      this.setLoading(false, chainNamespace);
      console.error("checkExistingSTelegramocialConnection error", error);
    }
    try {
      const url = new URL(window.location.href);
      url.searchParams.delete("result_uri");
      window.history.replaceState({}, document.title, url.toString());
    } catch (error) {
      console.error("tma social login failed", error);
    }
  }
  createAuthProvider(chainNamespace) {
    var _a2, _b, _c, _d;
    const isSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    if (!isSupported) {
      return;
    }
    const isEmailEnabled = (_a2 = this.remoteFeatures) == null ? void 0 : _a2.email;
    const isSocialsEnabled = Array.isArray((_b = this.remoteFeatures) == null ? void 0 : _b.socials) && this.remoteFeatures.socials.length > 0;
    const isAuthEnabled = isEmailEnabled || isSocialsEnabled;
    const activeNamespaceConnectedToAuth = HelpersUtil.getActiveNamespaceConnectedToAuth();
    const namespaceToConnect = activeNamespaceConnectedToAuth || chainNamespace;
    if (!this.authProvider && ((_c = this.options) == null ? void 0 : _c.projectId) && isAuthEnabled) {
      this.authProvider = W3mFrameProviderSingleton.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: (_d = this.getCaipNetwork(namespaceToConnect)) == null ? void 0 : _d.caipNetworkId,
        abortController: ErrorUtil.EmbeddedWalletAbortController,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        getActiveCaipNetwork: (namespace) => getActiveCaipNetwork(namespace),
        getCaipNetworks: (namespace) => ChainController.getCaipNetworks(namespace)
      });
      PublicStateController.subscribeOpen((isOpen) => {
        var _a3;
        if (!isOpen && this.isTransactionStackEmpty()) {
          (_a3 = this.authProvider) == null ? void 0 : _a3.rejectRpcRequests();
        }
      });
    }
    const shouldSyncAccount = chainNamespace === ChainController.state.activeChain && OptionsController.state.enableReconnect;
    if (OptionsController.state.enableReconnect === false) {
      this.syncAuthConnectorTheme(this.authProvider);
    } else if (this.authProvider && shouldSyncAccount) {
      this.syncAuthConnector(this.authProvider, chainNamespace);
      this.checkExistingTelegramSocialConnection(chainNamespace);
    }
  }
  createAuthProviderForAdapter(chainNamespace) {
    var _a2, _b, _c;
    this.createAuthProvider(chainNamespace);
    if (this.authProvider) {
      (_c = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setAuthProvider) == null ? void 0 : _c.call(_b, this.authProvider);
    }
  }
  // -- Overrides ----------------------------------------------------------------
  initControllers(options) {
    super.initControllers(options);
    if (this.options.excludeWalletIds) {
      ApiController.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
    }
  }
  async switchCaipNetwork(caipNetwork) {
    var _a2, _b;
    if (!caipNetwork) {
      return;
    }
    const currentNamespace = ChainController.state.activeChain;
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(networkNamespace);
    const isSameNamespace = networkNamespace === currentNamespace;
    if (isSameNamespace && namespaceAddress) {
      const adapter = this.getAdapter(networkNamespace);
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      this.setCaipNetwork(caipNetwork);
    } else {
      const currentNamespaceProviderType = ProviderUtil.getProviderId(currentNamespace);
      const isCurrentNamespaceAuthProvider = currentNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const newNamespaceProviderType = ProviderUtil.getProviderId(networkNamespace);
      const isNewNamespaceAuthProvider = newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const isNewNamespaceSupportsAuthConnector = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(networkNamespace);
      if (!networkNamespace) {
        throw new Error("AppKit:switchCaipNetwork - networkNamespace is required");
      }
      if ((isCurrentNamespaceAuthProvider && newNamespaceProviderType === void 0 || isNewNamespaceAuthProvider) && isNewNamespaceSupportsAuthConnector) {
        try {
          ChainController.state.activeChain = caipNetwork.chainNamespace;
          if (namespaceAddress) {
            const adapter = this.getAdapter(networkNamespace);
            await (adapter == null ? void 0 : adapter.switchNetwork({
              caipNetwork,
              provider: this.authProvider,
              providerType: newNamespaceProviderType
            }));
          } else {
            await ((_b = (_a2 = this.connectionControllerClient) == null ? void 0 : _a2.connectExternal) == null ? void 0 : _b.call(_a2, {
              id: ConstantsUtil.CONNECTOR_ID.AUTH,
              provider: this.authProvider,
              chain: networkNamespace,
              chainId: caipNetwork.id,
              type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
              caipNetwork
            }));
          }
          this.setCaipNetwork(caipNetwork);
        } catch (error) {
          const adapter = this.getAdapter(networkNamespace);
          await (adapter == null ? void 0 : adapter.switchNetwork({
            caipNetwork,
            provider: this.authProvider,
            providerType: newNamespaceProviderType
          }));
        }
      } else if (newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
        if (!ChainController.state.noAdapters) {
          const adapter = this.getAdapter(networkNamespace);
          const provider = ProviderUtil.getProvider(networkNamespace);
          const providerType = ProviderUtil.getProviderId(networkNamespace);
          await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
        }
        this.setCaipNetwork(caipNetwork);
        this.syncWalletConnectAccount();
      } else {
        this.setCaipNetwork(caipNetwork);
        if (namespaceAddress) {
          this.syncAccount({
            address: namespaceAddress,
            chainId: caipNetwork.id,
            chainNamespace: networkNamespace
          });
        }
      }
    }
  }
  async initialize(options) {
    var _a2;
    await super.initialize(options);
    (_a2 = this.chainNamespaces) == null ? void 0 : _a2.forEach((namespace) => {
      this.createAuthProviderForAdapter(namespace);
    });
    await this.injectModalUi();
    PublicStateController.set({ initialized: true });
  }
  async syncIdentity({ address, chainId, chainNamespace }) {
    var _a2;
    const caipNetworkId = `${chainNamespace}:${chainId}`;
    const activeCaipNetwork = (_a2 = this.caipNetworks) == null ? void 0 : _a2.find((n2) => n2.caipNetworkId === caipNetworkId);
    if (activeCaipNetwork == null ? void 0 : activeCaipNetwork.testnet) {
      this.setProfileName(null, chainNamespace);
      this.setProfileImage(null, chainNamespace);
      return;
    }
    const isAuthConnector = ConnectorController.getConnectorId(chainNamespace) === ConstantsUtil.CONNECTOR_ID.AUTH;
    try {
      const { name, avatar } = await this.fetchIdentity({
        address
      });
      if (!name && isAuthConnector) {
        await this.syncReownName(address, chainNamespace);
      } else {
        this.setProfileName(name, chainNamespace);
        this.setProfileImage(avatar, chainNamespace);
      }
    } catch {
      if (chainId !== 1) {
        this.setProfileImage(null, chainNamespace);
      }
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_AUTH) {
      const provider = this.authProvider;
      if (provider) {
        const social = StorageUtil.getConnectedSocialProvider() ?? "email";
        const identifier = provider.getEmail() ?? provider.getUsername();
        this.setConnectedWalletInfo({ name: providerType, identifier, social }, chainNamespace);
      }
    } else {
      super.syncConnectedWalletInfo(chainNamespace);
    }
  }
  async injectModalUi() {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    if (!isInitialized) {
      try {
        const features = { ...ConstantsUtil2.DEFAULT_FEATURES, ...this.options.features };
        const remoteFeatures = this.remoteFeatures;
        await this.loadModalComponents(features, remoteFeatures);
        if (CoreHelperUtil.isClient()) {
          const isElementCreated = document.querySelector("w3m-modal");
          if (!isElementCreated) {
            const modal = document.createElement("w3m-modal");
            if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
              document.body.insertAdjacentElement("beforeend", modal);
            }
          }
        }
        isInitialized = true;
      } catch (error) {
        console.error("Error injecting modal UI:", error);
      }
    }
  }
  // This separate method helps with tree-shaking for SSR builds
  async loadModalComponents(features, remoteFeatures) {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    const featureImportPromises = [];
    const usingEmbeddedWallet = remoteFeatures.email || remoteFeatures.socials && remoteFeatures.socials.length > 0;
    if (usingEmbeddedWallet) {
      featureImportPromises.push(import("./embedded-wallet-PFZLR4T4.js"));
    }
    if (remoteFeatures.email) {
      featureImportPromises.push(import("./email-F7SPL7XW.js"));
    }
    if (remoteFeatures.socials) {
      featureImportPromises.push(import("./socials-RLSBAJ2O.js"));
    }
    if (remoteFeatures.swaps && remoteFeatures.swaps.length > 0) {
      featureImportPromises.push(import("./swaps-MLCE6BJ2.js"));
    }
    if (features.send) {
      featureImportPromises.push(import("./send-XJABZYXB.js"));
    }
    if (features.receive) {
      featureImportPromises.push(import("./receive-XW6R4IF3.js"));
    }
    if (remoteFeatures.onramp && remoteFeatures.onramp.length > 0) {
      featureImportPromises.push(import("./onramp-VQKGI7QI.js"));
    }
    if (remoteFeatures.payWithExchange) {
      featureImportPromises.push(import("./pay-with-exchange-UIPKEJC6.js"));
    }
    if (remoteFeatures.activity) {
      featureImportPromises.push(import("./transactions-WFVL7UWX.js"));
    }
    if (features.pay || remoteFeatures.payments) {
      featureImportPromises.push(import("./exports-NZCPQ3PC.js"));
    }
    if (remoteFeatures.emailCapture) {
      featureImportPromises.push(import("./data-capture-KV2CBPBI.js"));
    }
    await Promise.all([
      ...featureImportPromises,
      import("./exports-UI7HRBDK.js"),
      import("./w3m-modal-YFHONPFP.js")
    ]);
  }
};

// ../node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.7.20";

// ../node_modules/@reown/appkit/dist/esm/exports/index.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    sdkVersion: CoreHelperUtil.generateSdkVersion(options.adapters ?? [], "html", PACKAGE_VERSION)
  });
}

// ../node_modules/@tronweb3/walletconnect-tron/lib/esm/errors.js
var ClientNotInitializedError = class _ClientNotInitializedError extends Error {
  constructor(message = "WalletConnect client is not initialized. Please call connect() first.") {
    super(message);
    this.name = "ClientNotInitializedError";
    Object.setPrototypeOf(this, _ClientNotInitializedError.prototype);
  }
};

// ../node_modules/@tronweb3/walletconnect-tron/lib/esm/utils.js
var WalletConnectChainID;
(function(WalletConnectChainID2) {
  WalletConnectChainID2["Mainnet"] = "tron:0x2b6653dc";
  WalletConnectChainID2["Shasta"] = "tron:0x94a9059e";
  WalletConnectChainID2["Nile"] = "tron:0xcd8690dc";
})(WalletConnectChainID || (WalletConnectChainID = {}));
var mainnet = defineChain({
  id: "0x2b6653dc",
  caipNetworkId: "tron:0x2b6653dc",
  chainNamespace: "tron",
  name: "Tron Mainnet",
  nativeCurrency: {
    decimals: 6,
    name: "TRX",
    symbol: "TRX"
  },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"],
      webSocket: [""]
    }
  },
  blockExplorers: {
    default: { name: "Tron BlockChain Explorer", url: "https://tronscan.org/" }
  },
  contracts: {}
});
var nileTestnet = defineChain({
  id: "0xcd8690dc",
  caipNetworkId: "tron:0xcd8690dc",
  chainNamespace: "tron",
  name: "Tron Nile Testnet",
  nativeCurrency: {
    decimals: 6,
    name: "TRX",
    symbol: "TRX"
  },
  rpcUrls: {
    default: {
      http: [""],
      webSocket: [""]
    }
  },
  blockExplorers: {
    default: { name: "Tron BlockChain Explorer", url: "https://nile.tronscan.org/" }
  },
  contracts: {}
});
var shastaTestnet = defineChain({
  id: "0x94a9059e",
  caipNetworkId: "tron:0x94a9059e",
  chainNamespace: "tron",
  name: "Tron Shasta Testnet",
  nativeCurrency: {
    decimals: 6,
    name: "TRX",
    symbol: "TRX"
  },
  rpcUrls: {
    default: {
      http: [""],
      webSocket: [""]
    }
  },
  blockExplorers: {
    default: { name: "Tron BlockChain Explorer", url: "https://shasta.tronscan.org/" }
  },
  contracts: {}
});
var NETWORK_MAP = /* @__PURE__ */ new Map([
  [WalletConnectChainID.Mainnet, mainnet],
  [WalletConnectChainID.Nile, nileTestnet],
  [WalletConnectChainID.Shasta, shastaTestnet]
]);

// ../node_modules/@tronweb3/walletconnect-tron/lib/esm/adapter.js
var WalletConnectMethods;
(function(WalletConnectMethods2) {
  WalletConnectMethods2["signTransaction"] = "tron_signTransaction";
  WalletConnectMethods2["signMessage"] = "tron_signMessage";
})(WalletConnectMethods || (WalletConnectMethods = {}));
var getConnectParams = (chainId, pairingTopic) => ({
  requiredNamespaces: {
    tron: {
      chains: [chainId],
      methods: [WalletConnectMethods.signTransaction, WalletConnectMethods.signMessage],
      events: []
    }
  },
  pairingTopic
});
var WalletConnectWallet = class {
  constructor(config) {
    this.providerPromise = null;
    this.eventListeners = /* @__PURE__ */ new Map();
    this.sessionHandlers = {};
    this.modalStateUnsubscribers = [];
    this.eventUnsubscribers = [];
    this.pendingModalCallbacks = [];
    this.pendingEventCallbacks = [];
    this._options = config.options;
    this._network = config.network;
    this._config = config;
  }
  async getProvider() {
    var _a2, _b, _c;
    if (this.provider)
      return this.provider;
    if (!this.providerPromise) {
      const projectId = this._options.projectId;
      if (!projectId) {
        throw new Error("[WalletConnectWallet] projectId is required to initialize UniversalProvider");
      }
      this.providerPromise = vs.init({
        projectId,
        logger: (_a2 = this._options) == null ? void 0 : _a2.logger,
        relayUrl: (_b = this._options) == null ? void 0 : _b.relayUrl,
        metadata: (_c = this._options) == null ? void 0 : _c.metadata
      }).catch((error) => {
        this.providerPromise = null;
        throw error;
      });
    }
    const provider = await this.providerPromise;
    this.provider = provider;
    this._client = provider.client;
    return provider;
  }
  extractAddressFromSession(session) {
    const accounts = Object.values(session.namespaces).flatMap((namespace) => namespace.accounts);
    const account = accounts[0];
    if (!account) {
      throw new Error("[WalletConnectWallet] No accounts found in session");
    }
    const address = account.split(":")[2];
    if (!address) {
      throw new Error(`[WalletConnectWallet] Invalid account format: ${account}`);
    }
    return address;
  }
  extractAllAddressesFromSession(session) {
    const accounts = Object.values(session.namespaces).flatMap((namespace) => namespace.accounts);
    if (!accounts || accounts.length === 0) {
      return [];
    }
    return accounts.map((account) => account.split(":")[2]).filter((addr) => !!addr);
  }
  emit(event, ...args) {
    var _a2;
    (_a2 = this.eventListeners.get(event)) == null ? void 0 : _a2.forEach((listener) => {
      try {
        listener(...args);
      } catch (error) {
        console.error(`[WalletConnectWallet] Error in ${event} listener:`, error);
      }
    });
  }
  on(event, listener) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(event).add(listener);
    return () => this.off(event, listener);
  }
  off(event, listener) {
    var _a2;
    (_a2 = this.eventListeners.get(event)) == null ? void 0 : _a2.delete(listener);
  }
  removeAllListeners(event) {
    if (event) {
      this.eventListeners.delete(event);
    } else {
      this.eventListeners.clear();
    }
  }
  setupSessionListeners() {
    if (!this._client || !this._session)
      return;
    const cleanup = () => {
      if (this._client) {
        this.sessionHandlers.update && this._client.off("session_update", this.sessionHandlers.update);
        this.sessionHandlers.delete && this._client.off("session_delete", this.sessionHandlers.delete);
      }
      this.sessionHandlers = {};
    };
    cleanup();
    this.sessionHandlers.update = ({ topic, params }) => {
      var _a2;
      if (!this._session || this._session.topic !== topic)
        return;
      let updated;
      try {
        updated = (_a2 = this._client) == null ? void 0 : _a2.session.get(topic);
      } catch (_) {
        return;
      }
      if (!updated)
        return;
      const oldAddresses = this.extractAllAddressesFromSession(this._session);
      this._session = { ...updated, namespaces: (params == null ? void 0 : params.namespaces) || updated.namespaces };
      this.address = this.extractAddressFromSession(this._session);
      const newAddresses = this.extractAllAddressesFromSession(this._session);
      const addressesChanged = JSON.stringify(oldAddresses) !== JSON.stringify(newAddresses);
      if (addressesChanged) {
        this.emit("accountsChanged", newAddresses);
      }
    };
    this.sessionHandlers.delete = ({ topic }) => {
      var _a2;
      if (((_a2 = this._session) == null ? void 0 : _a2.topic) === topic) {
        this._session = void 0;
        this.address = void 0;
        this.emit("disconnect");
        cleanup();
      }
    };
    this._client.on("session_update", this.sessionHandlers.update);
    this._client.on("session_delete", this.sessionHandlers.delete);
  }
  setupModalListeners() {
    if (!this.appKit)
      return;
    while (this.modalStateUnsubscribers.length > 0) {
      const unsubscribe = this.modalStateUnsubscribers.shift();
      unsubscribe();
    }
    while (this.eventUnsubscribers.length > 0) {
      const unsubscribe = this.eventUnsubscribers.shift();
      unsubscribe();
    }
    while (this.pendingModalCallbacks.length > 0) {
      const item = this.pendingModalCallbacks.shift();
      const unsubscribe = this.appKit.subscribeState(item.callback);
      this.modalStateUnsubscribers.push(unsubscribe);
      item.unsubscribeRef.fn = unsubscribe;
    }
    while (this.pendingEventCallbacks.length > 0) {
      const item = this.pendingEventCallbacks.shift();
      const unsubscribe = this.appKit.subscribeEvents(item.callback);
      this.eventUnsubscribers.push(unsubscribe);
      item.unsubscribeRef.fn = unsubscribe;
    }
  }
  async connect() {
    var _a2;
    const provider = await this.getProvider();
    const client = provider.client;
    const sessions = client.find(getConnectParams(this._network)).filter((s) => s.acknowledged);
    if (sessions.length) {
      this._session = sessions[sessions.length - 1];
      this._client = client;
      this.address = this.extractAddressFromSession(this._session);
      this.setupSessionListeners();
      const addresses = this.extractAllAddressesFromSession(this._session);
      this.emit("accountsChanged", addresses);
      return {
        address: this.address
      };
    } else {
      if (!this.appKit) {
        const {
          network,
          options,
          themeMode,
          themeVariables,
          allWallets,
          featuredWalletIds,
          includeWalletIds,
          excludeWalletIds,
          customWallets,
          enableAnalytics,
          debug,
          ...extraAppKitConfig
          // Spread any additional AppKit config
        } = this._config;
        const selectedNetwork = NETWORK_MAP.get(this._network);
        this.appKit = createAppKit({
          projectId: this._options.projectId,
          networks: [mainnet, nileTestnet, shastaTestnet],
          defaultNetwork: selectedNetwork,
          themeMode,
          themeVariables,
          allWallets: allWallets ?? "HIDE",
          featuredWalletIds,
          includeWalletIds,
          excludeWalletIds,
          customWallets,
          enableAnalytics,
          debug,
          manualWCControl: true,
          universalProvider: provider,
          ...extraAppKitConfig
          // Spread extra config options
        });
        this.setupModalListeners();
      }
      await this.appKit.open();
      try {
        let isConnected = false;
        let modalStateUnsubscribe;
        const connectPromise = provider.connect({
          pairingTopic: void 0,
          optionalNamespaces: getConnectParams(this._network).requiredNamespaces
        });
        const modalClosePromise = new Promise((_, reject) => {
          let isModalOpen = true;
          modalStateUnsubscribe = this.appKit.subscribeState((state) => {
            if (isModalOpen && !state.open && !isConnected) {
              reject(new Error("User closed the connection modal"));
            }
            isModalOpen = state.open;
          });
        });
        const session = await Promise.race([
          connectPromise.then((result) => {
            isConnected = true;
            return result;
          }),
          modalClosePromise
        ]).finally(() => {
          modalStateUnsubscribe == null ? void 0 : modalStateUnsubscribe();
        });
        this._session = session;
        this._client = client;
        this.address = this.extractAddressFromSession(this._session);
        this.setupSessionListeners();
        const addresses = this.extractAllAddressesFromSession(this._session);
        this.emit("accountsChanged", addresses);
        return { address: this.address };
      } catch (error) {
        throw error;
      } finally {
        await ((_a2 = this.appKit) == null ? void 0 : _a2.close());
      }
    }
  }
  async disconnect() {
    var _a2, _b, _c, _d;
    try {
      if (this._client) {
        this.sessionHandlers.update && this._client.off("session_update", this.sessionHandlers.update);
        this.sessionHandlers.delete && this._client.off("session_delete", this.sessionHandlers.delete);
        this.sessionHandlers = {};
      }
      while (this.modalStateUnsubscribers.length > 0) {
        const unsubscribe = this.modalStateUnsubscribers.shift();
        unsubscribe();
      }
      while (this.eventUnsubscribers.length > 0) {
        const unsubscribe = this.eventUnsubscribers.shift();
        unsubscribe();
      }
      const reason = Kt("USER_DISCONNECTED");
      const topic = ((_a2 = this._session) == null ? void 0 : _a2.topic) || ((_c = (_b = this.provider) == null ? void 0 : _b.session) == null ? void 0 : _c.topic);
      if (!topic)
        throw new ClientNotInitializedError();
      const client = ((_d = this.provider) == null ? void 0 : _d.client) || this._client;
      if (!client)
        throw new ClientNotInitializedError();
      await client.disconnect({ topic, reason });
    } finally {
      this._session = void 0;
      this.address = void 0;
    }
  }
  get client() {
    if (this._client)
      return this._client;
    throw new ClientNotInitializedError();
  }
  async checkConnectStatus() {
    const provider = await this.getProvider();
    const client = provider.client;
    const sessions = client.find(getConnectParams(this._network)).filter((s) => s.acknowledged);
    if (sessions.length) {
      this._session = sessions[sessions.length - 1];
      this._client = client;
      this.address = this.extractAddressFromSession(this._session);
      this.setupSessionListeners();
      const addresses = this.extractAllAddressesFromSession(this._session);
      this.emit("accountsChanged", addresses);
      return {
        address: this.address
      };
    } else {
      return {
        address: ""
      };
    }
  }
  async signTransaction(transaction) {
    if (this._client && this._session) {
      const sessionProperties = this._session.sessionProperties;
      const isV1Method = (sessionProperties == null ? void 0 : sessionProperties.tron_method_version) === "v1";
      const result = await this._client.request({
        chainId: this._network,
        topic: this._session.topic,
        request: {
          method: WalletConnectMethods.signTransaction,
          params: isV1Method ? {
            address: this.address,
            transaction
          } : {
            address: this.address,
            transaction: { transaction }
          }
        }
      });
      return (result == null ? void 0 : result.result) ? result.result : result;
    } else {
      throw new ClientNotInitializedError();
    }
  }
  async signMessage(message) {
    if (this._client && this._session) {
      const { signature } = await this._client.request({
        chainId: this._network,
        topic: this._session.topic,
        request: {
          method: WalletConnectMethods.signMessage,
          params: {
            address: this.address,
            message
          }
        }
      });
      return signature;
    } else {
      throw new ClientNotInitializedError();
    }
  }
  // ========== AppKit Method Pass-through ==========
  // The following methods expose AppKit functionality in manualWCControl mode.
  // Note: AppKit instance is created during the first connect() call.
  /**
   * Close the AppKit modal.
   * @throws {Error} If AppKit is not initialized
   */
  async closeModal() {
    if (!this.appKit) {
      throw new Error("[WalletConnectWallet] AppKit not initialized. Please call connect() first.");
    }
    await this.appKit.close();
  }
  /**
   * Set the theme mode (light or dark).
   * @param mode - 'light' or 'dark'
   * @throws {Error} If AppKit is not initialized
   */
  setThemeMode(mode) {
    if (!this.appKit) {
      throw new Error("[WalletConnectWallet] AppKit not initialized. Please call connect() first.");
    }
    this.appKit.setThemeMode(mode);
  }
  /**
   * Subscribe to AppKit modal state changes.
   * @param callback - Callback function called when state changes
   * @returns Unsubscribe function
   * @note Can be called before connect(). Subscription will be active after AppKit is initialized.
   */
  subscribeModalState(callback) {
    if (!this.appKit) {
      const unsubscribeRef = {};
      const item = { callback, unsubscribeRef };
      this.pendingModalCallbacks.push(item);
      return () => {
        if (unsubscribeRef.fn) {
          unsubscribeRef.fn();
          const index = this.modalStateUnsubscribers.indexOf(unsubscribeRef.fn);
          if (index > -1) {
            this.modalStateUnsubscribers.splice(index, 1);
          }
        } else {
          const index = this.pendingModalCallbacks.indexOf(item);
          if (index > -1) {
            this.pendingModalCallbacks.splice(index, 1);
          }
        }
      };
    }
    const unsubscribe = this.appKit.subscribeState(callback);
    this.modalStateUnsubscribers.push(unsubscribe);
    return () => {
      unsubscribe();
      const index = this.modalStateUnsubscribers.indexOf(unsubscribe);
      if (index > -1) {
        this.modalStateUnsubscribers.splice(index, 1);
      }
    };
  }
  /**
   * Subscribe to all AppKit events.
   * @param callback - Callback function called on each event
   * @returns Unsubscribe function
   * @note Can be called before connect(). Subscription will be active after AppKit is initialized.
   */
  subscribeEvents(callback) {
    if (!this.appKit) {
      const unsubscribeRef = {};
      const item = { callback, unsubscribeRef };
      this.pendingEventCallbacks.push(item);
      return () => {
        if (unsubscribeRef.fn) {
          unsubscribeRef.fn();
          const index = this.eventUnsubscribers.indexOf(unsubscribeRef.fn);
          if (index > -1) {
            this.eventUnsubscribers.splice(index, 1);
          }
        } else {
          const index = this.pendingEventCallbacks.indexOf(item);
          if (index > -1) {
            this.pendingEventCallbacks.splice(index, 1);
          }
        }
      };
    }
    const unsubscribe = this.appKit.subscribeEvents(callback);
    this.eventUnsubscribers.push(unsubscribe);
    return () => {
      unsubscribe();
      const index = this.eventUnsubscribers.indexOf(unsubscribe);
      if (index > -1) {
        this.eventUnsubscribers.splice(index, 1);
      }
    };
  }
};

// ../node_modules/@tronweb3/walletconnect-tron/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// ../node_modules/@tronweb3/walletconnect-tron/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());

// ../node_modules/@tronweb3/walletconnect-tron/node_modules/@walletconnect/core/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var Ue = "wc";
var pe = "core";
var W = `${Ue}@2:${pe}:`;
var Qs = import_time.FIVE_SECONDS * 1e3;
var Jt = "https://verify.walletconnect.org";
var be = Jt;
var Xt = `${be}/v3`;
function cr2(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++) t[i2] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s;
  }
  var a = r2.length, c = r2.charAt(0), h3 = Math.log(a) / Math.log(256), l2 = Math.log(256) / Math.log(a);
  function p(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u.length === 0) return "";
    for (var m2 = 0, D = 0, _ = 0, E2 = u.length; _ !== E2 && u[_] === 0; ) _++, m2++;
    for (var L = (E2 - _) * l2 + 1 >>> 0, I2 = new Uint8Array(L); _ !== E2; ) {
      for (var k2 = u[_], T = 0, S2 = L - 1; (k2 !== 0 || T < D) && S2 !== -1; S2--, T++) k2 += 256 * I2[S2] >>> 0, I2[S2] = k2 % a >>> 0, k2 = k2 / a >>> 0;
      if (k2 !== 0) throw new Error("Non-zero carry");
      D = T, _++;
    }
    for (var O2 = L - D; O2 !== L && I2[O2] === 0; ) O2++;
    for (var te = c.repeat(m2); O2 < L; ++O2) te += r2.charAt(I2[O2]);
    return te;
  }
  function y3(u) {
    if (typeof u != "string") throw new TypeError("Expected String");
    if (u.length === 0) return new Uint8Array();
    var m2 = 0;
    if (u[m2] !== " ") {
      for (var D = 0, _ = 0; u[m2] === c; ) D++, m2++;
      for (var E2 = (u.length - m2) * h3 + 1 >>> 0, L = new Uint8Array(E2); u[m2]; ) {
        var I2 = t[u.charCodeAt(m2)];
        if (I2 === 255) return;
        for (var k2 = 0, T = E2 - 1; (I2 !== 0 || k2 < _) && T !== -1; T--, k2++) I2 += a * L[T] >>> 0, L[T] = I2 % 256 >>> 0, I2 = I2 / 256 >>> 0;
        if (I2 !== 0) throw new Error("Non-zero carry");
        _ = k2, m2++;
      }
      if (u[m2] !== " ") {
        for (var S2 = E2 - _; S2 !== E2 && L[S2] === 0; ) S2++;
        for (var O2 = new Uint8Array(D + (E2 - S2)), te = D; S2 !== E2; ) O2[te++] = L[S2++];
        return O2;
      }
    }
  }
  function w(u) {
    var m2 = y3(u);
    if (m2) return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: y3, decode: w };
}
var hr = cr2;
var lr = hr;
var ni2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur = (r2) => new TextEncoder().encode(r2);
var dr = (r2) => new TextDecoder().decode(r2);
var gr = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var pr = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oi2(this, e);
  }
};
var yr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oi2(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2) return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var oi2 = (r2, e) => new yr({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br = class {
  constructor(e, t, i2, s) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s, this.encoder = new gr(e, t, i2), this.decoder = new pr(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se = ({ name: r2, prefix: e, encode: t, decode: i2 }) => new br(r2, e, t, i2);
var me = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i2, decode: s } = lr(t, e);
  return Se({ prefix: r2, name: e, encode: i2, decode: (n2) => ni2(s(n2)) });
};
var mr = (r2, e, t, i2) => {
  const s = {};
  for (let l2 = 0; l2 < e.length; ++l2) s[e[l2]] = l2;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a = 0, c = 0, h3 = 0;
  for (let l2 = 0; l2 < n2; ++l2) {
    const p = s[r2[l2]];
    if (p === void 0) throw new SyntaxError(`Non-${i2} character`);
    c = c << t | p, a += t, a >= 8 && (a -= 8, o2[h3++] = 255 & c >> a);
  }
  if (a >= t || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr = (r2, e, t) => {
  const i2 = e[e.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", o2 = 0, a = 0;
  for (let c = 0; c < r2.length; ++c) for (a = a << 8 | r2[c], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s & a >> o2];
  if (o2 && (n2 += e[s & a << t - o2]), i2) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var A2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i2 }) => Se({ prefix: e, name: r2, encode(s) {
  return fr(s, i2, t);
}, decode(s) {
  return mr(s, i2, t, r2);
} });
var Dr = Se({ prefix: "\0", name: "identity", encode: (r2) => dr(r2), decode: (r2) => ur(r2) });
var vr = Object.freeze({ __proto__: null, identity: Dr });
var wr = A2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var _r = Object.freeze({ __proto__: null, base2: wr });
var Er = A2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir = Object.freeze({ __proto__: null, base8: Er });
var Tr = me({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr = Object.freeze({ __proto__: null, base10: Tr });
var Pr = A2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr = A2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or = Object.freeze({ __proto__: null, base16: Pr, base16upper: Sr });
var Rr = A2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar = A2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr = A2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr = A2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r = A2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr = A2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr = A2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr = A2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr = A2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur = Object.freeze({ __proto__: null, base32: Rr, base32upper: Ar, base32pad: xr, base32padupper: Nr, base32hex: $r, base32hexupper: zr, base32hexpad: Lr, base32hexpadupper: kr, base32z: jr });
var Fr = me({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr = me({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base36: Fr, base36upper: Mr });
var Br = me({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr = me({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr = Object.freeze({ __proto__: null, base58btc: Br, base58flickr: Vr });
var Gr = A2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr = A2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr = A2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr = A2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr = Object.freeze({ __proto__: null, base64: Gr, base64pad: Wr, base64url: Hr, base64urlpad: Yr });
var ai = Array.from("");
var Xr = ai.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr = ai.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr(r2) {
  return r2.reduce((e, t) => (e += Xr[t], e), "");
}
function en(r2) {
  const e = [];
  for (const t of r2) {
    const i2 = Zr[t.codePointAt(0)];
    if (i2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var tn = Se({ prefix: "", name: "base256emoji", encode: Qr, decode: en });
var sn2 = Object.freeze({ __proto__: null, base256emoji: tn });
var rn = hi2;
var ci2 = 128;
var nn = 127;
var on = ~nn;
var an = Math.pow(2, 31);
function hi2(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r2 >= an; ) e[t++] = r2 & 255 | ci2, r2 /= 128;
  for (; r2 & on; ) e[t++] = r2 & 255 | ci2, r2 >>>= 7;
  return e[t] = r2 | 0, hi2.bytes = t - i2 + 1, e;
}
var cn = Ve;
var hn = 128;
var li = 127;
function Ve(r2, i2) {
  var t = 0, i2 = i2 || 0, s = 0, n2 = i2, o2, a = r2.length;
  do {
    if (n2 >= a) throw Ve.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s < 28 ? (o2 & li) << s : (o2 & li) * Math.pow(2, s), s += 7;
  } while (o2 >= hn);
  return Ve.bytes = n2 - i2, t;
}
var ln = Math.pow(2, 7);
var un = Math.pow(2, 14);
var dn = Math.pow(2, 21);
var gn = Math.pow(2, 28);
var pn = Math.pow(2, 35);
var yn = Math.pow(2, 42);
var bn = Math.pow(2, 49);
var mn = Math.pow(2, 56);
var fn = Math.pow(2, 63);
var Dn = function(r2) {
  return r2 < ln ? 1 : r2 < un ? 2 : r2 < dn ? 3 : r2 < gn ? 4 : r2 < pn ? 5 : r2 < yn ? 6 : r2 < bn ? 7 : r2 < mn ? 8 : r2 < fn ? 9 : 10;
};
var vn = { encode: rn, decode: cn, encodingLength: Dn };
var ui = vn;
var di2 = (r2, e, t = 0) => (ui.encode(r2, e, t), e);
var gi = (r2) => ui.encodingLength(r2);
var qe = (r2, e) => {
  const t = e.byteLength, i2 = gi(r2), s = i2 + gi(t), n2 = new Uint8Array(s + t);
  return di2(r2, n2, 0), di2(t, n2, i2), n2.set(e, s), new wn(r2, t, e, n2);
};
var wn = class {
  constructor(e, t, i2, s) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s;
  }
};
var pi2 = ({ name: r2, code: e, encode: t }) => new _n(r2, e, t);
var _n = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe(this.code, t) : t.then((i2) => qe(this.code, i2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var yi = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En = pi2({ name: "sha2-256", code: 18, encode: yi("SHA-256") });
var In = pi2({ name: "sha2-512", code: 19, encode: yi("SHA-512") });
var Tn = Object.freeze({ __proto__: null, sha256: En, sha512: In });
var bi = 0;
var Cn = "identity";
var mi = ni2;
var Pn = (r2) => qe(bi, mi(r2));
var Sn = { code: bi, name: Cn, encode: mi, digest: Pn };
var On = Object.freeze({ __proto__: null, identity: Sn });
new TextEncoder(), new TextDecoder();
var fi2 = { ...vr, ..._r, ...Ir, ...Cr, ...Or, ...Ur, ...Kr, ...qr, ...Jr, ...sn2 };
({ ...Tn, ...On });
function Di(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Di(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function vi(r2, e, t, i2) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var wi = vi("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge = vi("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An = { utf8: wi, "utf-8": wi, hex: fi2.base16, latin1: Ge, ascii: Ge, binary: Ge, ...fi2 };

// ../node_modules/@tronweb3/walletconnect-tron/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time2 = __toESM(require_cjs());
var Ce = "wc";
var ke = 2;
var De2 = "client";
var we = `${Ce}@${ke}:${De2}:`;
var _t = "wc";
var ft = "auth";
var le2 = `${_t}@${1.5}:${ft}:`;
var pe2 = `${le2}:PUB_KEY`;

// ../node_modules/@tronweb3/tronwallet-adapter-walletconnect/lib/esm/adapter.js
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WalletConnectWalletName = "WalletConnect";
var NETWORK = Object.keys(ChainNetwork);
var validThemeVariables = [
  "--w3m-font-family",
  "--w3m-accent",
  "--w3m-color-mix",
  "--w3m-color-mix-strength",
  "--w3m-font-size-master",
  "--w3m-border-radius-master",
  "--w3m-z-index",
  "--w3m-qr-color"
];
var WalletConnectAdapter = class extends Adapter {
  constructor(config) {
    var _a2, _b, _c, _d, _e;
    super();
    this.name = WalletConnectWalletName;
    this.url = "https://walletconnect.org";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNjEuNDM4NTQsOTQuMDAzOGM0OC45MTEyMywtNDcuODg4MTcgMTI4LjIxMTk5LC00Ny44ODgxNyAxNzcuMTIzMjEsMGw1Ljg4NjU1LDUuNzYzNDJjMi40NDU1NiwyLjM5NDQxIDIuNDQ1NTYsNi4yNzY1MSAwLDguNjcwOTJsLTIwLjEzNjcsMTkuNzE1NWMtMS4yMjI3OCwxLjE5NzIxIC0zLjIwNTMsMS4xOTcyMSAtNC40MjgwOCwwbC04LjEwMDU4LC03LjkzMTE1Yy0zNC4xMjE2OSwtMzMuNDA3OTggLTg5LjQ0Mzg5LC0zMy40MDc5OCAtMTIzLjU2NTU4LDBsLTguNjc1MDYsOC40OTM2MWMtMS4yMjI3OCwxLjE5NzIgLTMuMjA1MywxLjE5NzIgLTQuNDI4MDgsMGwtMjAuMTM2NjksLTE5LjcxNTVjLTIuNDQ1NTYsLTIuMzk0NDEgLTIuNDQ1NTYsLTYuMjc2NTIgMCwtOC42NzA5Mmw2LjQ2MTAxLC02LjMyNTg4em0yMTguNzY3OCw0MC43NzM3NWwxNy45MjE3LDE3LjU0Njg5YzIuNDQ1NTQsMi4zOTQ0IDIuNDQ1NTYsNi4yNzY0OCAwLjAwMDAzLDguNjcwODlsLTgwLjgxMDE3LDc5LjEyMTE0Yy0yLjQ0NTU1LDIuMzk0NDIgLTYuNDEwNTksMi4zOTQ0NSAtOC44NTYxNiwwLjAwMDA2Yy0wLjAwMDAxLC0wLjAwMDAxIC0wLjAwMDAzLC0wLjAwMDAyIC0wLjAwMDA0LC0wLjAwMDAzbC01Ny4zNTQxNCwtNTYuMTU0NThjLTAuNjExMzksLTAuNTk4NiAtMS42MDI2NSwtMC41OTg2IC0yLjIxNDA0LDBjMCwwLjAwMDAxIC0wLjAwMDAxLDAuMDAwMDEgLTAuMDAwMDEsMC4wMDAwMmwtNTcuMzUyOTIsNTYuMTU0NTNjLTIuNDQ1NTQsMi4zOTQ0MyAtNi40MTA1OCwyLjM5NDQ3IC04Ljg1NjE2LDAuMDAwMDhjLTAuMDAwMDIsLTAuMDAwMDEgLTAuMDAwMDMsLTAuMDAwMDIgLTAuMDAwMDUsLTAuMDAwMDRsLTgwLjgxMjQyLC03OS4xMjIxOWMtMi40NDU1NiwtMi4zOTQ0IC0yLjQ0NTU2LC02LjI3NjUxIDAsLTguNjcwOTFsMTcuOTIxNzMsLTE3LjU0Njg3YzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMGw1Ny4zNTQ5OCw1Ni4xNTUzNWMwLjYxMTM5LDAuNTk4NjEgMS42MDI2NSwwLjU5ODYxIDIuMjE0MDQsMGMwLjAwMDAxLDAgMC4wMDAwMiwtMC4wMDAwMSAwLjAwMDAzLC0wLjAwMDAybDU3LjM1MjEsLTU2LjE1NTMzYzIuNDQ1NSwtMi4zOTQ0NyA2LjQxMDU0LC0yLjM5NDU2IDguODU2MTYsLTAuMDAwMmMwLjAwMDAzLDAuMDAwMDMgMC4wMDAwNywwLjAwMDA3IDAuMDAwMSwwLjAwMDFsNTcuMzU0OSw1Ni4xNTU0M2MwLjYxMTM5LDAuNTk4NiAxLjYwMjY1LDAuNTk4NiAyLjIxNDA0LDBsNTcuMzUzOTgsLTU2LjE1NDMyYzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMHoiIGZpbGw9IiMzYjk5ZmMiIGlkPSJzdmdfMSIvPjwvc3ZnPg==";
    this._readyState = WalletReadyState.Found;
    this._state = AdapterState.Disconnect;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnected", this._disconnected);
        wallet.off("accountsChanged", this._accountsChanged);
        this._address = null;
        this._state = AdapterState.Disconnect;
        this.emit("disconnect");
        this.emit("stateChanged", this._state);
      }
    };
    this._accountsChanged = (curAddr) => {
      const preAddress = this.address;
      this._address = (curAddr === null || curAddr === void 0 ? void 0 : curAddr[0]) || "";
      this.emit("accountsChanged", this.address || "", preAddress || "");
    };
    config = Object.assign({}, config);
    if (!config || typeof config !== "object") {
      throw new Error(`[WalletconnectAdapter] config is required.`);
    }
    if (!config.network) {
      console.error(`[WalletconnectAdapter] config.network must be one of ${NETWORK.join()} or a chainID such as 0x2b6653dc. Use Nile network instead.`);
      config.network = "Nile";
    }
    if (!config.options) {
      throw new Error(`[WalletconnectAdapter] config.options is required.`);
    }
    const themeVariables = {};
    if ((_a2 = config.web3ModalConfig) === null || _a2 === void 0 ? void 0 : _a2.themeVariables) {
      Object.entries(config.web3ModalConfig.themeVariables).forEach(([k2, v]) => {
        const w3mKey = k2.replace("--wcm-", "--w3m-");
        if (validThemeVariables.includes(w3mKey)) {
          themeVariables[w3mKey] = v;
        }
      });
    }
    config.themeMode = config.themeMode || ((_b = config.web3ModalConfig) === null || _b === void 0 ? void 0 : _b.themeMode);
    config.themeVariables = config.themeVariables || themeVariables;
    config.featuredWalletIds = config.featuredWalletIds || (((_c = config.web3ModalConfig) === null || _c === void 0 ? void 0 : _c.explorerRecommendedWalletIds) === "NONE" ? void 0 : (_d = config.web3ModalConfig) === null || _d === void 0 ? void 0 : _d.explorerRecommendedWalletIds);
    config.privacyPolicyUrl = config.privacyPolicyUrl || ((_e = config.web3ModalConfig) === null || _e === void 0 ? void 0 : _e.privacyPolicyUrl);
    Reflect.deleteProperty(config, "web3ModalConfig");
    this._connecting = false;
    this._wallet = null;
    this._address = null;
    this._config = config;
  }
  get address() {
    return this._address;
  }
  get readyState() {
    return this._readyState;
  }
  get state() {
    return this._state;
  }
  /**
   * Currently unused for WalletConnectAdapter.
   */
  get connecting() {
    return this._connecting;
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (this.connected)
          return;
        if (this.state === AdapterState.NotFound)
          throw new WalletNotFoundError();
        this._connecting = true;
        let address = "";
        try {
          if (!this._wallet) {
            this._wallet = new WalletConnectWallet(Object.assign(Object.assign({}, this._config), { network: WalletConnectChainID[this._config.network] || `tron:${this._config.network}` }));
          }
          ({ address } = yield this._wallet.connect());
        } catch (error) {
          if (error.message === "User closed the connection modal")
            throw new WalletWindowClosedError();
          throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);
        }
        this._wallet.on("disconnect", this._disconnected);
        this._wallet.on("accountsChanged", this._accountsChanged);
        this._address = address || "";
        this._state = AdapterState.Connected;
        this.emit("stateChanged", this._state);
        this.emit("connect", address);
      } catch (error) {
        this.emit("error", error);
        throw error;
      } finally {
      }
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state === AdapterState.NotFound || !this.connected) {
        return;
      }
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        wallet.off("accountsChanged", this._accountsChanged);
        this._address = null;
        try {
          yield wallet.disconnect();
        } catch (error) {
          this.emit("error", new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));
        }
      }
      this._state = AdapterState.Disconnect;
      this.emit("disconnect");
      this.emit("stateChanged", this._state);
    });
  }
  signTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state !== AdapterState.Connected)
        throw new WalletDisconnectedError();
      try {
        const wallet = this._wallet;
        if (!wallet)
          throw new WalletDisconnectedError();
        try {
          return yield wallet.signTransaction(transaction);
        } catch (error) {
          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const wallet = this._wallet;
        if (!wallet)
          throw new WalletDisconnectedError();
        try {
          return yield wallet.signMessage(message);
        } catch (error) {
          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);
        }
      } catch (error) {
        this.emit("error", error);
        throw error;
      }
    });
  }
  /**
   * Get WalletConnect connection status.
   * Address is not empty if the WalletConnectWallet is connected.
   * @returns {object} status
   * @property {string} status.address - connected address
   */
  getConnectionStatus() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._wallet || !this.connected) {
        return { address: "" };
      }
      try {
        return yield this._wallet.checkConnectStatus();
      } catch (e) {
        this._address = null;
        this._state = AdapterState.Disconnect;
        return { address: "" };
      }
    });
  }
};

export {
  WalletConnectWalletName,
  WalletConnectAdapter
};
//# sourceMappingURL=chunk-SECN3WU6.js.map
